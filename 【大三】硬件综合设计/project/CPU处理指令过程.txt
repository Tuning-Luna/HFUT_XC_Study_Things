CPU处理指令的完整过程

本CPU采用单周期架构，每条指令在一个时钟周期内完成从取指到写回的完整过程。虽然所有阶段在同一个时钟周期内完成，但为了清晰说明，我们按照五个阶段来描述指令的处理流程。

第一阶段：取指阶段（Instruction Fetch, IF）

取指阶段的主要任务是从指令存储器中读取当前指令。

1. PC寄存器提供当前指令地址：PC寄存器存储当前程序计数器的值，在时钟上升沿时，PC寄存器会更新为下一个PC值。复位时PC被初始化为0x00000000。

2. 指令存储器读取指令：PC寄存器的输出pc_current作为地址输入到指令存储器模块。指令存储器根据这个地址读取对应的32位指令。指令存储器的容量为128条指令（512字节），采用字对齐访问方式，即忽略地址的低2位。

3. 指令输出：指令存储器将读取到的32位指令通过instruction信号输出，这条指令将进入下一阶段的处理。

4. PC更新准备：在取指的同时，系统会计算PC+4的值，为顺序执行做准备。如果当前指令是分支或跳转指令，PC的下一个值将由分支或跳转逻辑决定。

第二阶段：译码阶段（Instruction Decode, ID）

译码阶段的主要任务是解析指令字段、生成控制信号、读取寄存器数据。

1. 指令字段解析：从32位指令中提取各个字段。操作码opcode从指令的第31到26位提取，用于识别指令类型。源寄存器rs从指令的第25到21位提取，用于指定第一个源寄存器。源寄存器rt从指令的第20到16位提取，用于指定第二个源寄存器或目标寄存器。目标寄存器rd从指令的第15到11位提取，用于R-type指令的目标寄存器。功能码funct从指令的第5到0位提取，用于R-type指令指定具体操作。立即数immediate从指令的第15到0位提取，用于I-type指令。跳转地址jump_addr从指令的第25到0位提取，用于J-type指令。

2. 主控制单元生成控制信号：控制单元根据操作码opcode生成各种控制信号。对于R-type指令（opcode为0x00），控制单元设置reg_dst为1表示目标寄存器是rd，设置alu_op为2'b10表示ALU操作由功能码决定，设置reg_write为1表示需要写寄存器。对于lw指令（opcode为0x23），控制单元设置alu_src为1表示ALU第二个输入是立即数，设置mem_to_reg为1表示写入数据来自内存，设置reg_write为1表示需要写寄存器，设置mem_read为1表示需要读内存，设置alu_op为2'b00表示ALU执行加法用于计算地址。对于sw指令（opcode为0x2B），控制单元设置alu_src为1表示ALU第二个输入是立即数，设置mem_write为1表示需要写内存，设置alu_op为2'b00表示ALU执行加法用于计算地址。对于beq指令（opcode为0x04），控制单元设置branch为1表示可能分支，设置alu_op为2'b01表示ALU执行减法用于比较。对于addi指令（opcode为0x08），控制单元设置alu_src为1表示ALU第二个输入是立即数，设置reg_write为1表示需要写寄存器，设置alu_op为2'b00表示ALU执行加法。对于j指令（opcode为0x02），控制单元设置jump为1表示执行跳转。

3. ALU控制单元生成ALU控制信号：ALU控制单元根据主控制单元输出的alu_op和指令的funct字段生成具体的ALU控制信号。当alu_op为2'b00时，表示lw、sw或addi指令，ALU控制单元输出ALU_ADD控制信号，使ALU执行加法运算。当alu_op为2'b01时，表示beq指令，ALU控制单元输出ALU_SUB控制信号，使ALU执行减法运算用于比较。当alu_op为2'b10时，表示R-type指令，ALU控制单元根据funct字段决定具体操作：funct为0x20时输出ALU_ADD用于add指令，funct为0x22时输出ALU_SUB用于sub指令，funct为0x24时输出ALU_AND用于and指令，funct为0x25时输出ALU_OR用于or指令，funct为0x2A时输出ALU_SLT用于slt指令。

4. 寄存器文件读取数据：寄存器文件根据rs和rt字段读取两个源寄存器的数据。如果rs或rt为0，则读取的数据恒为0（因为$0寄存器硬件实现为恒0）。读取操作是组合逻辑，立即输出read_data1和read_data2。

5. 立即数符号扩展：对于I-type指令，需要将16位立即数符号扩展为32位。符号扩展的方法是：如果立即数的最高位为1，则高16位填充1；如果最高位为0，则高16位填充0。这样可以正确处理有符号立即数。

第三阶段：执行阶段（Execute, EX）

执行阶段的主要任务是ALU执行运算，计算分支目标地址等。

1. ALU输入选择：ALU的第一个输入始终是read_data1（从寄存器文件读取的第一个数据）。ALU的第二个输入由alu_src控制信号选择：当alu_src为0时，选择read_data2（从寄存器文件读取的第二个数据），用于R-type指令；当alu_src为1时，选择sign_extended（符号扩展后的立即数），用于I-type指令。

2. ALU执行运算：ALU根据alu_control信号执行相应的运算。当alu_control为ALU_ADD时，执行加法运算result等于input1加input2。当alu_control为ALU_SUB时，执行减法运算result等于input1减input2。当alu_control为ALU_AND时，执行按位与运算result等于input1按位与input2。当alu_control为ALU_OR时，执行按位或运算result等于input1按位或input2。当alu_control为ALU_SLT时，执行小于比较运算，如果input1小于input2则result为1，否则为0。ALU还会生成zero标志，当运算结果为0时zero为1，用于beq指令的条件判断。

3. 分支目标地址计算：对于beq指令，需要计算分支目标地址。分支目标地址等于PC+4加上符号扩展后的立即数左移2位（因为地址是字对齐的，需要乘以4）。

4. 跳转目标地址计算：对于j指令，需要计算跳转目标地址。跳转目标地址等于PC+4的高4位拼接跳转地址左移2位。

第四阶段：访存阶段（Memory Access, MEM）

访存阶段的主要任务是访问数据存储器，只有lw和sw指令需要这个阶段。

1. 内存地址计算：ALU的输出alu_out作为数据存储器的访问地址。对于lw和sw指令，这个地址是基址寄存器加上立即数偏移量计算得到的。

2. 内存读操作：对于lw指令，mem_read信号为1，数据存储器根据地址读取数据，并通过read_data信号输出。读操作是组合逻辑，立即输出结果。

3. 内存写操作：对于sw指令，mem_write信号为1，在时钟上升沿时，数据存储器将read_data2（要写入的数据）写入到地址alu_out指定的位置。写操作是时序逻辑，在时钟上升沿完成。

4. 非访存指令：对于不需要访存的指令（如R-type指令、addi指令等），虽然ALU结果也会连接到数据存储器，但由于mem_read和mem_write都为0，数据存储器不会执行任何操作。

第五阶段：写回阶段（Write Back, WB）

写回阶段的主要任务是将结果写回寄存器文件。

1. 写入寄存器选择：根据reg_dst控制信号选择写入的目标寄存器。当reg_dst为1时，选择rd（R-type指令的目标寄存器）；当reg_dst为0时，选择rt（I-type指令的目标寄存器）。

2. 写入数据选择：根据mem_to_reg控制信号选择写入的数据来源。当mem_to_reg为1时，选择mem_data（从数据存储器读取的数据，用于lw指令）；当mem_to_reg为0时，选择alu_out（ALU的运算结果，用于R-type指令和addi指令）。

3. 寄存器写入：如果reg_write信号为1，则在时钟上升沿时，将write_data写入到write_reg指定的寄存器中。如果write_reg为0（$0寄存器），则不会执行写入操作，因为$0寄存器硬件实现为恒0。写操作是时序逻辑，在时钟上升沿完成。

PC更新逻辑

PC的下一个值由以下逻辑决定：

1. 跳转指令：如果jump信号为1，则PC的下一个值等于跳转目标地址，即PC+4的高4位拼接跳转地址左移2位。

2. 分支指令：如果branch信号为1且alu_zero信号为1（表示两个寄存器值相等），则PC的下一个值等于分支目标地址，即PC+4加上符号扩展后的立即数左移2位。

3. 顺序执行：如果既不是跳转也不是分支，则PC的下一个值等于PC+4，即顺序执行下一条指令。

PC寄存器在时钟上升沿时更新为pc_next的值，完成一个指令周期的处理。

不同类型指令的处理流程示例

R-type指令（以add指令为例）：取指阶段从指令存储器读取指令，译码阶段解析出opcode为0x00、rs、rt、rd和funct字段，控制单元生成reg_dst为1、alu_op为2'b10、reg_write为1等控制信号，ALU控制单元根据funct生成ALU_ADD控制信号，寄存器文件读取rs和rt寄存器的值，执行阶段ALU执行加法运算，访存阶段不执行任何操作，写回阶段将ALU结果写入rd寄存器，PC更新为PC+4。

I-type指令lw（以lw $t0, 4($s0)为例）：取指阶段从指令存储器读取指令，译码阶段解析出opcode为0x23、rs为$s0、rt为$t0、immediate为4，控制单元生成alu_src为1、mem_to_reg为1、reg_write为1、mem_read为1、alu_op为2'b00等控制信号，ALU控制单元生成ALU_ADD控制信号，寄存器文件读取$s0的值，立即数4进行符号扩展，执行阶段ALU计算$s0加4得到内存地址，访存阶段从数据存储器读取该地址的数据，写回阶段将内存数据写入$t0寄存器，PC更新为PC+4。

I-type指令sw（以sw $t0, 4($s0)为例）：取指阶段从指令存储器读取指令，译码阶段解析出opcode为0x2B、rs为$s0、rt为$t0、immediate为4，控制单元生成alu_src为1、mem_write为1、alu_op为2'b00等控制信号，ALU控制单元生成ALU_ADD控制信号，寄存器文件读取$s0和$t0的值，立即数4进行符号扩展，执行阶段ALU计算$s0加4得到内存地址，访存阶段在时钟上升沿将$t0的值写入该内存地址，写回阶段不执行任何操作（reg_write为0），PC更新为PC+4。

I-type指令beq（以beq $t0, $t1, label为例）：取指阶段从指令存储器读取指令，译码阶段解析出opcode为0x04、rs为$t0、rt为$t1、immediate为标签偏移量，控制单元生成branch为1、alu_op为2'b01等控制信号，ALU控制单元生成ALU_SUB控制信号，寄存器文件读取$t0和$t1的值，立即数进行符号扩展，执行阶段ALU执行$t0减$t1的运算，如果结果为0则alu_zero为1，同时计算分支目标地址，访存阶段不执行任何操作，写回阶段不执行任何操作，PC更新：如果alu_zero为1则PC更新为分支目标地址，否则更新为PC+4。

I-type指令addi（以addi $t0, $t1, 10为例）：取指阶段从指令存储器读取指令，译码阶段解析出opcode为0x08、rs为$t1、rt为$t0、immediate为10，控制单元生成alu_src为1、reg_write为1、alu_op为2'b00等控制信号，ALU控制单元生成ALU_ADD控制信号，寄存器文件读取$t1的值，立即数10进行符号扩展，执行阶段ALU执行$t1加10的运算，访存阶段不执行任何操作，写回阶段将ALU结果写入$t0寄存器，PC更新为PC+4。

J-type指令j（以j label为例）：取指阶段从指令存储器读取指令，译码阶段解析出opcode为0x02、jump_addr为标签地址，控制单元生成jump为1等控制信号，执行阶段计算跳转目标地址，访存阶段不执行任何操作，写回阶段不执行任何操作，PC更新为跳转目标地址。

单周期CPU的特点

单周期CPU的特点是每条指令在一个时钟周期内完成所有五个阶段。这意味着时钟周期必须足够长，以容纳最慢指令的延迟。对于本设计，时钟周期需要满足：指令存储器读取延迟、控制信号生成延迟、寄存器文件读取延迟、ALU运算延迟、数据存储器访问延迟、多路选择器延迟、以及PC更新延迟的总和。

虽然单周期CPU的性能相对较低，但它的优点是结构简单清晰，便于理解和验证，是学习CPU设计的理想起点。所有操作都在组合逻辑中完成（除了寄存器写入、内存写入和PC更新等时序操作），数据通路清晰，控制逻辑直接，非常适合教学和调试。
