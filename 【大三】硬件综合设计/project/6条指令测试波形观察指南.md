# 6 条指令测试程序 - 波形观察指南

## 一、测试程序概述

本测试程序用于验证以下 6 条指令的正确性：

1. **add** (R-type) - 寄存器加法
2. **sub** (R-type) - 寄存器减法
3. **and** (R-type) - 按位与
4. **or** (R-type) - 按位或
5. **slt** (R-type) - 小于则置位
6. **addi** (I-type) - 立即数加法

## 二、测试程序逻辑

### 2.1 初始化阶段

- `$t0 = 7` (测试操作数 1)
- `$t1 = 9` (测试操作数 2)
- `$s0 = 0x100` (数据存储基地址)

### 2.2 测试指令执行

| PC 地址 | 指令              | 功能                  | 预期结果 | 存储地址        |
| ------- | ----------------- | --------------------- | -------- | --------------- |
| 0x0C    | add $t2, $t0, $t1 | $t2 = 7 + 9           | $t2 = 16 | mem[0x100] = 16 |
| 0x14    | sub $t3, $t0, $t1 | $t3 = 7 - 9           | $t3 = -2 | mem[0x104] = -2 |
| 0x1C    | and $t4, $t0, $t1 | $t4 = 7 & 9           | $t4 = 1  | mem[0x108] = 1  |
| 0x24    | or $t5, $t0, $t1  | $t5 = 7 \| 9          | $t5 = 15 | mem[0x10C] = 15 |
| 0x2C    | slt $t6, $t1, $t0 | $t6 = (9 < 7) ? 1 : 0 | $t6 = 0  | mem[0x110] = 0  |
| 0x34    | addi $t7, $t0, 10 | $t7 = 7 + 10          | $t7 = 17 | mem[0x114] = 17 |

### 2.3 验证阶段

- 使用 `lw` 指令读取结果
- 使用 `beq` 指令验证结果正确性

## 三、关键波形观察点

### 3.1 必须观察的信号

#### 1. 基本控制信号

- `testbench.clk` - 时钟信号（周期 10ns）
- `testbench.rst` - 复位信号
- `testbench.pc_out` - 程序计数器（PC 值）

#### 2. 指令相关信号

- `testbench.uut.instruction` - 当前执行的指令
- `testbench.uut.opcode` - 指令操作码
- `testbench.uut.reg_write` - 寄存器写使能
- `testbench.uut.mem_write` - 内存写使能
- `testbench.uut.mem_read` - 内存读使能

#### 3. 寄存器值（重点观察）

- `testbench.uut.u_regfile.registers[8]` - **$t0 = 7**（测试操作数 1）
- `testbench.uut.u_regfile.registers[9]` - **$t1 = 9**（测试操作数 2）
- `testbench.uut.u_regfile.registers[10]` - **$t2**（add 结果，应为 16）
- `testbench.uut.u_regfile.registers[11]` - **$t3**（sub 结果，应为 -2）
- `testbench.uut.u_regfile.registers[12]` - **$t4**（and 结果，应为 1）
- `testbench.uut.u_regfile.registers[13]` - **$t5**（or 结果，应为 15）
- `testbench.uut.u_regfile.registers[14]` - **$t6**（slt 结果，应为 0）
- `testbench.uut.u_regfile.registers[15]` - **$t7**（addi 结果，应为 17）
- `testbench.uut.u_regfile.registers[16]` - **$s0 = 0x100**（基地址）

#### 4. ALU 相关信号

- `testbench.uut.alu_out` - ALU 运算结果
- `testbench.uut.alu_zero` - ALU 零标志
- `testbench.uut.alu_control` - ALU 控制信号

#### 5. 内存数据（重点观察）

- `testbench.uut.u_dmem.mem[64]` - **地址 0x100，add 结果 = 16**
- `testbench.uut.u_dmem.mem[65]` - **地址 0x104，sub 结果 = -2**
- `testbench.uut.u_dmem.mem[66]` - **地址 0x108，and 结果 = 1**
- `testbench.uut.u_dmem.mem[67]` - **地址 0x10C，or 结果 = 15**
- `testbench.uut.u_dmem.mem[68]` - **地址 0x110，slt 结果 = 0**
- `testbench.uut.u_dmem.mem[69]` - **地址 0x114，addi 结果 = 17**

## 四、详细波形观察步骤

### 4.1 打开波形文件

```bash
gtkwave cpu_test.vcd
```

### 4.2 添加关键信号到波形窗口

在 GTKWave 中，按以下顺序添加信号：

#### 步骤 1：添加基本信号

1. 展开 `testbench`
2. 添加 `clk`、`rst`、`pc_out`

#### 步骤 2：添加指令和控制信号

1. 展开 `testbench.uut`
2. 添加 `instruction`、`opcode`
3. 添加 `reg_write`、`mem_write`、`mem_read`

#### 步骤 3：添加寄存器（重点）

1. 展开 `testbench.uut.u_regfile.registers`
2. 添加以下寄存器：
   - `registers[8]` - $t0
   - `registers[9]` - $t1
   - `registers[10]` - $t2 (add 结果)
   - `registers[11]` - $t3 (sub 结果)
   - `registers[12]` - $t4 (and 结果)
   - `registers[13]` - $t5 (or 结果)
   - `registers[14]` - $t6 (slt 结果)
   - `registers[15]` - $t7 (addi 结果)
   - `registers[16]` - $s0

#### 步骤 4：添加 ALU 信号

1. 展开 `testbench.uut`
2. 添加 `alu_out`、`alu_zero`

#### 步骤 5：添加内存数据（重点）

1. 展开 `testbench.uut.u_dmem.mem`
2. 添加 `mem[64]` 到 `mem[69]`（对应地址 0x100-0x114）

### 4.3 设置显示格式

- **PC、地址、指令**：右键 → Data Format → Hexadecimal
- **寄存器值、内存值、ALU 结果**：右键 → Data Format → Decimal（或 Signed Decimal）
- **控制信号**：保持 Binary 格式

## 五、各指令的波形验证要点

### 5.1 ADD 指令验证（PC = 0x0C）

**观察时刻**：PC = 0x0C 的时钟周期

**关键观察点**：

1. **指令字段**：

   - `instruction = 0x01095020`
   - `opcode = 0x00` (R-type)
   - `rs = 8` ($t0), `rt = 9` ($t1), `rd = 10` ($t2)

2. **控制信号**：

   - `reg_write = 1`（需要写寄存器）
   - `reg_dst = 1`（目标寄存器是 rd）
   - `alu_op = 2'b10`（R-type 指令）

3. **寄存器值**：

   - `registers[8]` ($t0) = 7
   - `registers[9]` ($t1) = 9
   - **下一个周期**：`registers[10]` ($t2) = **16** ✓

4. **ALU 结果**：

   - `alu_out = 16`（7 + 9 = 16）

5. **内存写入**（PC = 0x10）：
   - `mem_write = 1`
   - `mem[64]` (地址 0x100) = **16** ✓

### 5.2 SUB 指令验证（PC = 0x14）

**观察时刻**：PC = 0x14 的时钟周期

**关键观察点**：

1. **指令字段**：

   - `instruction = 0x01095822`
   - `opcode = 0x00` (R-type)
   - `funct = 0x22` (sub)

2. **ALU 结果**：

   - `alu_out = -2`（7 - 9 = -2）

3. **寄存器值**：

   - **下一个周期**：`registers[11]` ($t3) = **-2** ✓

4. **内存写入**（PC = 0x18）：
   - `mem[65]` (地址 0x104) = **-2** ✓

### 5.3 AND 指令验证（PC = 0x1C）

**观察时刻**：PC = 0x1C 的时钟周期

**关键观察点**：

1. **指令字段**：

   - `instruction = 0x01096024`
   - `funct = 0x24` (and)

2. **ALU 结果**：

   - `alu_out = 1`（7 & 9 = 0b0111 & 0b1001 = 0b0001 = 1）

3. **寄存器值**：

   - **下一个周期**：`registers[12]` ($t4) = **1** ✓

4. **内存写入**（PC = 0x20）：
   - `mem[66]` (地址 0x108) = **1** ✓

### 5.4 OR 指令验证（PC = 0x24）

**观察时刻**：PC = 0x24 的时钟周期

**关键观察点**：

1. **指令字段**：

   - `instruction = 0x01096825`
   - `funct = 0x25` (or)

2. **ALU 结果**：

   - `alu_out = 15`（7 \| 9 = 0b0111 \| 0b1001 = 0b1111 = 15）

3. **寄存器值**：

   - **下一个周期**：`registers[13]` ($t5) = **15** ✓

4. **内存写入**（PC = 0x28）：
   - `mem[67]` (地址 0x10C) = **15** ✓

### 5.5 SLT 指令验证（PC = 0x2C）

**观察时刻**：PC = 0x2C 的时钟周期

**关键观察点**：

1. **指令字段**：

   - `instruction = 0x0128702a`
   - `rs = 9` ($t1 = 9), `rt = 8` ($t0 = 7)
   - `funct = 0x2A` (slt)

2. **ALU 结果**：

   - `alu_out = 0`（因为 9 > 7，所以结果为 0）

3. **寄存器值**：

   - **下一个周期**：`registers[14]` ($t6) = **0** ✓

4. **内存写入**（PC = 0x30）：
   - `mem[68]` (地址 0x110) = **0** ✓

### 5.6 ADDI 指令验证（PC = 0x34）

**观察时刻**：PC = 0x34 的时钟周期

**关键观察点**：

1. **指令字段**：

   - `instruction = 0x210f000a`
   - `opcode = 0x08` (addi)
   - `rs = 8` ($t0 = 7), `rt = 15` ($t7)
   - `immediate = 0x000A` (10)

2. **控制信号**：

   - `alu_src = 1`（ALU 第二个输入是立即数）
   - `reg_write = 1`

3. **立即数扩展**：

   - 符号扩展后的立即数 = 10

4. **ALU 结果**：

   - `alu_out = 17`（7 + 10 = 17）

5. **寄存器值**：

   - **下一个周期**：`registers[15]` ($t7) = **17** ✓

6. **内存写入**（PC = 0x38）：
   - `mem[69]` (地址 0x114) = **17** ✓

## 六、PC 值变化序列

**预期 PC 变化**：

```
0x00 → 0x04 → 0x08 → 0x0C → 0x10 → 0x14 → 0x18 → 0x1C → 0x20
→ 0x24 → 0x28 → 0x2C → 0x30 → 0x34 → 0x38 → 0x3C → 0x40 → 0x44 → 0x50
```

**关键 PC 地址**：

- `0x00-0x08`：初始化阶段（设置$t0, $t1, $s0）
- `0x0C`：**ADD 指令**
- `0x14`：**SUB 指令**
- `0x1C`：**AND 指令**
- `0x24`：**OR 指令**
- `0x2C`：**SLT 指令**
- `0x34`：**ADDI 指令**
- `0x3C-0x44`：验证阶段（lw, beq）
- `0x50`：程序结束（无限循环）

## 七、验证检查清单

### 7.1 初始化验证

- [ ] PC 从 0x00000000 开始
- [ ] 复位后，所有寄存器初始化为 0（除了$0 恒为 0）
- [ ] PC = 0x00 时，`registers[8]` ($t0) = 7
- [ ] PC = 0x04 时，`registers[9]` ($t1) = 9
- [ ] PC = 0x08 时，`registers[16]` ($s0) = 0x100

### 7.2 ADD 指令验证

- [ ] PC = 0x0C 时，指令 = 0x01095020
- [ ] `reg_write = 1`
- [ ] `alu_out = 16`
- [ ] 下一个周期，`registers[10]` = 16
- [ ] PC = 0x10 时，`mem[64]` = 16

### 7.3 SUB 指令验证

- [ ] PC = 0x14 时，指令 = 0x01095822
- [ ] `alu_out = -2`
- [ ] 下一个周期，`registers[11]` = -2
- [ ] PC = 0x18 时，`mem[65]` = -2

### 7.4 AND 指令验证

- [ ] PC = 0x1C 时，指令 = 0x01096024
- [ ] `alu_out = 1`
- [ ] 下一个周期，`registers[12]` = 1
- [ ] PC = 0x20 时，`mem[66]` = 1

### 7.5 OR 指令验证

- [ ] PC = 0x24 时，指令 = 0x01096825
- [ ] `alu_out = 15`
- [ ] 下一个周期，`registers[13]` = 15
- [ ] PC = 0x28 时，`mem[67]` = 15

### 7.6 SLT 指令验证

- [ ] PC = 0x2C 时，指令 = 0x0128702a
- [ ] `alu_out = 0`（因为 9 > 7）
- [ ] 下一个周期，`registers[14]` = 0
- [ ] PC = 0x30 时，`mem[68]` = 0

### 7.7 ADDI 指令验证

- [ ] PC = 0x34 时，指令 = 0x210f000a
- [ ] `alu_src = 1`（使用立即数）
- [ ] `alu_out = 17`
- [ ] 下一个周期，`registers[15]` = 17
- [ ] PC = 0x38 时，`mem[69]` = 17

### 7.8 最终结果验证

- [ ] `mem[64]` = 16 ✓
- [ ] `mem[65]` = -2 ✓
- [ ] `mem[66]` = 1 ✓
- [ ] `mem[67]` = 15 ✓
- [ ] `mem[68]` = 0 ✓
- [ ] `mem[69]` = 17 ✓

## 八、常见问题排查

### 问题 1：寄存器值不正确

- **检查**：控制信号`reg_write`是否为 1
- **检查**：ALU 结果`alu_out`是否正确
- **检查**：寄存器写入地址`write_reg`是否正确

### 问题 2：内存值不正确

- **检查**：控制信号`mem_write`是否为 1
- **检查**：内存地址`alu_out`是否正确
- **检查**：写入数据`read_data2`是否正确

### 问题 3：ALU 结果不正确

- **检查**：ALU 控制信号`alu_control`是否正确
- **检查**：ALU 输入`input1`和`input2`是否正确
- **检查**：对于 R-type 指令，`funct`字段是否正确解析

### 问题 4：PC 跳转不正确

- **检查**：分支信号`branch`和`jump`是否正确
- **检查**：`alu_zero`标志是否正确
- **检查**：分支目标地址计算是否正确

## 九、总结

通过观察以上波形，可以全面验证 6 条指令的正确性：

1. **ADD**：验证寄存器加法运算
2. **SUB**：验证寄存器减法运算
3. **AND**：验证按位与运算
4. **OR**：验证按位或运算
5. **SLT**：验证小于比较运算
6. **ADDI**：验证立即数加法运算

所有测试结果都存储在内存的 0x100-0x114 地址，可以通过波形直接观察验证。

---

**文档版本**：1.1
**更新日期**：2026-01-12
**用途**：6 条指令测试程序的波形观察指南
