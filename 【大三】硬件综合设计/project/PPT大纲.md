# 单周期 MIPS32 CPU 设计 - PPT 大纲

## 目录

1. [项目概述](#1-项目概述)
2. [设计目标与要求](#2-设计目标与要求)
3. [CPU 架构设计](#3-cpu-架构设计)
4. [模块划分与功能](#4-模块划分与功能)
5. [模块关系图](#5-模块关系图)
6. [支持的指令集](#6-支持的指令集)
7. [数据通路设计](#7-数据通路设计)
8. [测试程序：斐波那契数列](#8-测试程序斐波那契数列)
9. [仿真验证与结果](#9-仿真验证与结果)
10. [项目总结](#10-项目总结)

---

## 1. 项目概述

### 1.1 项目背景

- **课程名称**：硬件综合设计
- **设计目标**：基于 MIPS32 精简指令集架构，完成单周期 CPU 设计
- **技术栈**：Verilog HDL、iverilog、GTKWave、Vivado
- **应用场景**：FPGA 实现，可下载到开发板运行测试程序

### 1.2 项目特点

- **架构类型**：单周期 CPU（每条指令在一个时钟周期内完成）
- **指令集**：MIPS32 精简指令集
- **支持指令数**：10 条指令
- **数据宽度**：32 位
- **测试程序**：斐波那契数列计算（前 10 项）

### 1.3 项目文件结构

```
项目根目录/
├── 核心设计文件（8个）
│   ├── cpu_top.v              # CPU 顶层模块
│   ├── pc_register.v          # PC 寄存器
│   ├── instruction_memory.v   # 指令存储器
│   ├── control_unit.v         # 控制单元
│   ├── register_file.v        # 寄存器文件
│   ├── alu_control.v          # ALU 控制单元
│   ├── alu.v                  # 算术逻辑单元
│   └── data_memory.v          # 数据存储器
├── 测试文件
│   └── testbench.v            # 测试平台
├── 脚本文件
│   └── run.bat                # 运行脚本
└── 文档文件
    ├── README.md
    ├── CPU设计说明文档.md
    ├── 斐波那契数列运行指标说明.md
    └── Vivado工程建立与模块设计说明.md
```

---

## 2. 设计目标与要求

### 2.1 课程要求

- ✅ 基于 MIPS32 精简指令集架构
- ✅ 完成单周期 CPU 设计
- ✅ 支持指令条数不少于 10 条
- ✅ 可下载至 FPGA 芯片
- ✅ 在开发板上运行测试程序并验证

### 2.2 技术指标

- **CPU 架构**：单周期 CPU
- **数据宽度**：32 位
- **寄存器数量**：32 个通用寄存器
- **指令存储器容量**：128 条指令（512 字节）
- **数据存储器容量**：256 个字（1KB）
- **时钟频率**：100MHz（仿真）

---

## 3. CPU 架构设计

### 3.1 单周期 CPU 原理

- **定义**：每条指令在一个时钟周期内完成所有阶段
- **五个阶段**：
  1. **取指（IF）**：从指令存储器读取指令
  2. **译码（ID）**：解析指令字段，生成控制信号
  3. **执行（EX）**：ALU 执行运算
  4. **访存（MEM）**：访问数据存储器（仅 lw/sw）
  5. **写回（WB）**：将结果写回寄存器

### 3.2 设计优势

- **结构简单**：易于理解和实现
- **控制逻辑清晰**：控制信号生成直接
- **适合教学**：便于理解 CPU 工作原理

### 3.3 设计挑战

- **时钟周期限制**：所有操作必须在一个周期内完成
- **关键路径优化**：需要平衡各模块的延迟

---

## 4. 模块划分与功能

### 4.1 模块层次结构

```
cpu_top (顶层模块)
├── pc_register          # PC 寄存器
├── instruction_memory   # 指令存储器
├── control_unit         # 控制单元
├── register_file        # 寄存器文件
├── alu_control          # ALU 控制单元
├── alu                  # 算术逻辑单元
└── data_memory          # 数据存储器
```

### 4.2 各模块详细说明

#### 4.2.1 PC 寄存器模块 (pc_register.v)

- **功能**：存储程序计数器（PC），每个时钟周期更新
- **关键特性**：
  - 复位时 PC = 0x00000000
  - 支持顺序执行、分支和跳转
  - 时钟上升沿更新

#### 4.2.2 指令存储器模块 (instruction_memory.v)

- **功能**：存储程序指令，根据 PC 值读取指令
- **关键特性**：
  - 容量：128 条指令（512 字节）
  - 预装载斐波那契数列计算程序
  - 字对齐访问（忽略地址低 2 位）

#### 4.2.3 控制单元模块 (control_unit.v)

- **功能**：根据指令操作码生成所有控制信号
- **输出控制信号**：
  - `reg_dst`：寄存器目标选择
  - `jump`：跳转信号
  - `branch`：分支信号
  - `mem_read`：内存读信号
  - `mem_to_reg`：数据源选择
  - `alu_op`：ALU 操作类型
  - `mem_write`：内存写信号
  - `alu_src`：ALU 源选择
  - `reg_write`：寄存器写使能

#### 4.2.4 寄存器文件模块 (register_file.v)

- **功能**：32 个 32 位通用寄存器，支持 2 读 1 写
- **关键特性**：
  - $0 寄存器恒为 0（硬件实现）
  - 读操作：组合逻辑（立即输出）
  - 写操作：时序逻辑（时钟上升沿）

#### 4.2.5 ALU 控制单元模块 (alu_control.v)

- **功能**：根据 ALU_OP 和功能码生成 ALU 控制信号
- **输入**：
  - `alu_op`：来自控制单元（2 位）
  - `funct`：R-type 指令功能码（6 位）
- **输出**：4 位 ALU 控制信号

#### 4.2.6 ALU 模块 (alu.v)

- **功能**：执行算术和逻辑运算
- **支持的运算**：
  - ADD（加法）
  - SUB（减法）
  - AND（按位与）
  - OR（按位或）
  - SLT（小于则置位）
  - NOR（或非）
- **输出**：运算结果和零标志

#### 4.2.7 数据存储器模块 (data_memory.v)

- **功能**：存储和读取数据
- **关键特性**：
  - 容量：256 个字（1KB）
  - 字对齐访问（忽略地址低 2 位）
  - 读操作：组合逻辑
  - 写操作：时序逻辑（时钟上升沿）

#### 4.2.8 CPU 顶层模块 (cpu_top.v)

- **功能**：整合所有子模块，实现单周期 CPU 的完整数据通路
- **关键功能**：
  - 连接所有子模块
  - 实现数据通路（指令获取、译码、执行、访存、写回）
  - 处理分支和跳转逻辑
  - 实现多路选择器（MUX）功能

---

## 5. 模块关系图

### 5.1 模块依赖关系图

```
┌─────────────────────────────────────────────────────────────┐
│                      testbench.v                            │
│                    (测试平台模块)                            │
│  - 生成时钟和复位信号                                         │
│  - 实例化 CPU 顶层模块                                       │
│  - 生成波形文件并验证结果                                     │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       │ 实例化
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                      cpu_top.v                              │
│                    (CPU 顶层模块)                            │
│  - 整合所有子模块                                             │
│  - 实现数据通路连接                                           │
│  - 处理分支和跳转逻辑                                         │
└───┬──────┬──────┬──────┬──────┬──────┬──────┬──────────────┘
    │      │      │      │      │      │      │
    │      │      │      │      │      │      │
    ▼      ▼      ▼      ▼      ▼      ▼      ▼
┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐
│  PC  │ │ 指令 │ │ 控制 │ │ 寄存 │ │ ALU  │ │ ALU  │ │ 数据 │
│ 寄存 │ │ 存储 │ │ 单元 │ │ 器文 │ │ 控制 │ │      │ │ 存储 │
│  器  │ │  器  │ │      │ │  件  │ │ 单元 │ │      │ │  器  │
└──────┘ └──────┘ └──────┘ └──────┘ └──────┘ └──────┘ └──────┘
```

### 5.2 数据流向关系图

```
                    ┌─────────────┐
                    │   PC 寄存器  │
                    │ (pc_register)│
                    └──────┬───────┘
                           │ pc_current
                           ▼
                    ┌─────────────┐
                    │  指令存储器  │
                    │(instruction │
                    │  _memory)   │
                    └──────┬───────┘
                           │ instruction
                           ▼
        ┌──────────────────┴──────────────────┐
        │                                      │
        ▼                                      ▼
┌──────────────┐                    ┌──────────────┐
│   控制单元    │                    │  寄存器文件   │
│(control_unit)│                    │(register_file)│
└──────┬───────┘                    └──────┬───────┘
       │                                   │
       │ 控制信号                           │ read_data1/2
       │                                   │
       ▼                                   ▼
┌──────────────┐                    ┌──────────────┐
│ ALU 控制单元  │                    │     ALU      │
│(alu_control) │                    │   (alu.v)    │
└──────┬───────┘                    └──────┬───────┘
       │                                   │
       │ alu_control                       │ alu_out
       │                                   │
       └───────────┬───────────────────────┘
                   │
                   ▼
            ┌──────────────┐
            │  数据存储器   │
            │(data_memory) │
            └──────────────┘
```

### 5.3 控制信号流向关系图

```
指令 (instruction)
    │
    ├─► opcode ──► 控制单元 (control_unit)
    │                    │
    │                    ├─► reg_dst ──► MUX (选择写入寄存器)
    │                    ├─► jump ──► PC 跳转控制
    │                    ├─► branch ──► 分支控制
    │                    ├─► mem_read ──► 数据存储器读使能
    │                    ├─► mem_to_reg ──► MUX (选择写回数据)
    │                    ├─► alu_op ──► ALU 控制单元
    │                    ├─► mem_write ──► 数据存储器写使能
    │                    ├─► alu_src ──► MUX (选择 ALU 输入)
    │                    └─► reg_write ──► 寄存器文件写使能
    │
    └─► funct ──► ALU 控制单元 (alu_control)
                        │
                        └─► alu_control ──► ALU (alu.v)
```

### 5.4 指令执行数据通路关系图

```
┌─────────────────────────────────────────────────────────────┐
│                    单周期 CPU 数据通路                        │
└─────────────────────────────────────────────────────────────┘

取指阶段 (IF):
    PC ──► 指令存储器 ──► 指令

译码阶段 (ID):
    指令 ──┬─► 控制单元 ──► 控制信号
           │
           ├─► 寄存器文件 ──► 寄存器数据
           │
           └─► 指令字段解析 (opcode, rs, rt, rd, funct, immediate)

执行阶段 (EX):
    寄存器数据/立即数 ──► ALU ──► 运算结果
    控制信号 ──► ALU 控制单元 ──► ALU 操作类型

访存阶段 (MEM):
    ALU 结果 ──► 数据存储器 ──► 内存数据 (仅 lw/sw)

写回阶段 (WB):
    ALU 结果/内存数据 ──► 寄存器文件 ──► 更新寄存器
```

### 5.5 模块间信号连接关系说明

#### 5.5.1 PC 寄存器 ↔ 指令存储器

- **连接关系**：`pc_current` → `instruction_memory.addr`
- **数据流**：PC 值作为地址输入到指令存储器
- **方向**：单向（PC → 指令存储器）

#### 5.5.2 指令存储器 ↔ 控制单元

- **连接关系**：`instruction[31:26]` → `control_unit.opcode`
- **数据流**：指令的操作码字段输入到控制单元
- **方向**：单向（指令存储器 → 控制单元）

#### 5.5.3 控制单元 ↔ ALU 控制单元

- **连接关系**：`control_unit.alu_op` → `alu_control.alu_op`
- **数据流**：控制单元输出的 ALU 操作类型输入到 ALU 控制单元
- **方向**：单向（控制单元 → ALU 控制单元）

#### 5.5.4 ALU 控制单元 ↔ ALU

- **连接关系**：`alu_control.alu_control` → `alu.alu_control`
- **数据流**：ALU 控制信号输入到 ALU
- **方向**：单向（ALU 控制单元 → ALU）

#### 5.5.5 寄存器文件 ↔ ALU

- **连接关系**：
  - `register_file.read_data1` → `alu.input1`
  - `register_file.read_data2` → MUX → `alu.input2`
- **数据流**：寄存器数据输入到 ALU
- **方向**：单向（寄存器文件 → ALU）

#### 5.5.6 ALU ↔ 数据存储器

- **连接关系**：`alu.result` → `data_memory.addr`
- **数据流**：ALU 结果作为数据存储器的地址
- **方向**：单向（ALU → 数据存储器）

#### 5.5.7 数据存储器 ↔ 寄存器文件

- **连接关系**：`data_memory.read_data` → MUX → `register_file.write_data`
- **数据流**：内存数据写回寄存器文件
- **方向**：单向（数据存储器 → 寄存器文件）

#### 5.5.8 控制单元 ↔ 各模块

- **连接关系**：控制单元输出多个控制信号到各个模块
- **控制信号**：
  - `reg_write` → 寄存器文件
  - `mem_read`, `mem_write` → 数据存储器
  - `reg_dst`, `mem_to_reg`, `alu_src` → MUX 选择器
  - `branch`, `jump` → PC 更新逻辑

---

## 6. 支持的指令集

### 6.1 指令分类

| 指令类型 | 指令数量 | 指令列表               |
| -------- | -------- | ---------------------- |
| R-type   | 5 条     | add, sub, and, or, slt |
| I-type   | 4 条     | lw, sw, beq, addi      |
| J-type   | 1 条     | j                      |

### 6.2 指令详细列表

| 序号 | 指令 | 类型   | 操作码             | 功能描述                                             |
| ---- | ---- | ------ | ------------------ | ---------------------------------------------------- |
| 1    | add  | R-type | 0x00 (funct: 0x20) | 寄存器加法：$rd = $rs + $rt                          |
| 2    | sub  | R-type | 0x00 (funct: 0x22) | 寄存器减法：$rd = $rs - $rt                          |
| 3    | and  | R-type | 0x00 (funct: 0x24) | 按位与：$rd = $rs & $rt                              |
| 4    | or   | R-type | 0x00 (funct: 0x25) | 按位或：$rd = $rs \| $rt                             |
| 5    | slt  | R-type | 0x00 (funct: 0x2A) | 小于则置位：$rd = ($rs < $rt) ? 1 : 0                |
| 6    | lw   | I-type | 0x23               | 从内存加载字：$rt = mem[$rs + imm]                   |
| 7    | sw   | I-type | 0x2B               | 向内存存储字：mem[$rs + imm] = $rt                   |
| 8    | beq  | I-type | 0x04               | 相等则分支：if ($rs == $rt) PC = PC + 4 + (imm << 2) |
| 9    | addi | I-type | 0x08               | 立即数加法：$rt = $rs + imm                          |
| 10   | j    | J-type | 0x02               | 无条件跳转：PC = {PC[31:28], addr, 2'b00}            |

### 6.3 指令格式说明

#### R-type 指令格式

```
31-26  25-21  20-16  15-11  10-6   5-0
opcode   rs     rt     rd   shamt  funct
  6位    5位    5位    5位    5位    6位
```

#### I-type 指令格式

```
31-26  25-21  20-16  15-0
opcode   rs     rt   immediate
  6位    5位    5位    16位
```

#### J-type 指令格式

```
31-26  25-0
opcode  address
  6位    26位
```

---

## 7. 数据通路设计

### 7.1 单周期数据通路五个阶段

#### 阶段 1：取指（IF - Instruction Fetch）

- **功能**：从指令存储器读取指令
- **数据流**：PC → 指令存储器 → 指令
- **关键信号**：`pc_current`, `instruction`

#### 阶段 2：译码（ID - Instruction Decode）

- **功能**：解析指令字段，生成控制信号，读取寄存器
- **数据流**：
  - 指令 → 控制单元 → 控制信号
  - 指令字段（rs, rt）→ 寄存器文件 → 寄存器数据
- **关键信号**：`opcode`, `rs`, `rt`, `rd`, `funct`, `read_data1`, `read_data2`

#### 阶段 3：执行（EX - Execute）

- **功能**：ALU 执行运算
- **数据流**：
  - 寄存器数据/立即数 → ALU → 运算结果
  - 控制信号 → ALU 控制单元 → ALU 操作类型
- **关键信号**：`alu_input1`, `alu_input2`, `alu_control`, `alu_out`, `alu_zero`

#### 阶段 4：访存（MEM - Memory Access）

- **功能**：访问数据存储器（仅 lw/sw 指令）
- **数据流**：
  - ALU 结果 → 数据存储器地址
  - 寄存器数据 → 数据存储器写入数据（sw）
  - 数据存储器 → 读取数据（lw）
- **关键信号**：`mem_addr`, `mem_write_data`, `mem_read_data`, `mem_write`, `mem_read`

#### 阶段 5：写回（WB - Write Back）

- **功能**：将结果写回寄存器
- **数据流**：
  - ALU 结果/内存数据 → MUX → 寄存器文件写入数据
- **关键信号**：`write_data`, `write_reg`, `reg_write`

### 7.2 关键数据通路连接

#### 7.2.1 PC 更新通路

```
PC 当前值 ──► PC + 4 ──┬─► MUX ──► PC 下一个值
                        │
分支目标地址 ──────────┤
                        │
跳转目标地址 ──────────┘
```

#### 7.2.2 ALU 输入选择通路

```
寄存器数据2 ──┬─► MUX ──► ALU 输入2
              │
符号扩展立即数 ─┘
```

#### 7.2.3 寄存器写入选择通路

```
ALU 结果 ──┬─► MUX ──► 寄存器写入数据
           │
内存读取数据 ─┘
```

#### 7.2.4 寄存器目标选择通路

```
rt (I-type) ──┬─► MUX ──► 写入寄存器编号
              │
rd (R-type) ──┘
```

### 7.3 分支和跳转逻辑

#### 分支逻辑

```
beq 指令：
  - branch = 1
  - ALU 执行减法：$rs - $rt
  - 如果 alu_zero = 1，则 PC = PC + 4 + (imm << 2)
  - 否则 PC = PC + 4
```

#### 跳转逻辑

```
j 指令：
  - jump = 1
  - PC = {PC[31:28], jump_addr, 2'b00}
```

---

## 8. 测试程序：斐波那契数列

### 8.1 程序功能

计算斐波那契数列的前 10 项，并存储到数据存储器的 0x100-0x124 地址。

### 8.2 算法逻辑

```
初始化：
  fib[0] = 0
  fib[1] = 1
  counter = 2

循环（counter < 10）：
  fib[counter] = fib[counter-1] + fib[counter-2]
  存储到内存地址 0x100 + counter * 4
  counter++

结束：
  无限循环
```

### 8.3 寄存器使用策略

| 寄存器 | 编号 | 用途                   | 初始值 | 变化说明                                  |
| ------ | ---- | ---------------------- | ------ | ----------------------------------------- |
| $t0    | 8    | fib[n-2]（前前一个数） | 0      | 0 → 1 → 1 → 2 → 3 → 5 → 8 → 13 → 21       |
| $t1    | 9    | fib[n-1]（前一个数）   | 1      | 1 → 1 → 2 → 3 → 5 → 8 → 13 → 21 → 34      |
| $t2    | 10   | fib[n]（当前数）       | -      | 在循环中计算：$t2 = $t0 + $t1             |
| $t3    | 11   | 循环计数器             | 2      | 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 10        |
| $t4    | 12   | 循环上限               | 10     | 固定值：10                                |
| $t5    | 13   | 内存地址偏移           | 8      | 8 → 12 → 16 → 20 → 24 → 28 → 32 → 36 → 40 |
| $s0    | 16   | 数据存储基地址         | 0x100  | 固定值：0x100                             |

### 8.4 内存布局

| 内存索引 | 物理地址 | 斐波那契索引 | 预期值 | 说明            |
| -------- | -------- | ------------ | ------ | --------------- |
| mem[64]  | 0x100    | fib[0]       | 0      | 初始化阶段写入  |
| mem[65]  | 0x104    | fib[1]       | 1      | 初始化阶段写入  |
| mem[66]  | 0x108    | fib[2]       | 1      | 第 1 次循环写入 |
| mem[67]  | 0x10C    | fib[3]       | 2      | 第 2 次循环写入 |
| mem[68]  | 0x110    | fib[4]       | 3      | 第 3 次循环写入 |
| mem[69]  | 0x114    | fib[5]       | 5      | 第 4 次循环写入 |
| mem[70]  | 0x118    | fib[6]       | 8      | 第 5 次循环写入 |
| mem[71]  | 0x11C    | fib[7]       | 13     | 第 6 次循环写入 |
| mem[72]  | 0x120    | fib[8]       | 21     | 第 7 次循环写入 |
| mem[73]  | 0x124    | fib[9]       | 34     | 第 8 次循环写入 |

### 8.5 程序执行流程

```
PC = 0x00: addi $t0, $0, 0        // $t0 = 0
PC = 0x04: addi $t1, $0, 1        // $t1 = 1
PC = 0x08: addi $t3, $0, 2        // $t3 = 2 (counter)
PC = 0x0C: addi $t4, $0, 10       // $t4 = 10 (limit)
PC = 0x10: addi $t5, $0, 8        // $t5 = 8 (offset)
PC = 0x14: addi $s0, $0, 0x100    // $s0 = 0x100 (base address)
PC = 0x18: sw $t0, 0($s0)         // 存储 fib[0] = 0
PC = 0x1C: sw $t1, 4($s0)         // 存储 fib[1] = 1
PC = 0x20: add $t2, $t0, $t1      // $t2 = $t0 + $t1 (LOOP开始)
PC = 0x24: add $t0, $0, $t1       // $t0 = $t1 (更新前前一个数)
PC = 0x28: add $t1, $0, $t2       // $t1 = $t2 (更新前一个数)
PC = 0x2C: add $t6, $s0, $t5      // $t6 = $s0 + $t5 (计算存储地址)
PC = 0x30: sw $t2, 0($t6)         // 存储当前斐波那契数
PC = 0x34: addi $t3, $t3, 1       // counter++
PC = 0x38: addi $t5, $t5, 4       // offset += 4
PC = 0x3C: sub $t7, $t4, $t3      // $t7 = $t4 - $t3
PC = 0x40: beq $t7, $0, END       // if ($t7 == 0) goto END
PC = 0x44: j LOOP                 // 跳转到 LOOP
PC = 0x48: (END标签，无限循环)
```

---

## 9. 仿真验证与结果

### 9.1 仿真环境

- **仿真工具**：iverilog + GTKWave
- **FPGA 工具**：Vivado（用于综合和下载）
- **运行脚本**：run.bat（Windows）

### 9.2 运行步骤

#### 步骤 1：编译和仿真

```bash
run.bat
```

#### 步骤 2：查看控制台输出

```
========================================
斐波那契数列计算完成
========================================
存储在内存中的斐波那契数列：
fib[0] = 0 (地址 0x100)
fib[1] = 1 (地址 0x104)
fib[2] = 1 (地址 0x108)
fib[3] = 2 (地址 0x10C)
fib[4] = 3 (地址 0x110)
fib[5] = 5 (地址 0x114)
fib[6] = 8 (地址 0x118)
fib[7] = 13 (地址 0x11C)
fib[8] = 21 (地址 0x120)
fib[9] = 34 (地址 0x124)
========================================
✓ 测试通过！斐波那契数列计算正确。
========================================
```

#### 步骤 3：查看波形文件

```bash
gtkwave cpu_test.vcd
```

### 9.3 关键观察指标

#### 9.3.1 PC 寄存器变化

- **初始值**：复位后 PC = 0x00000000
- **递增规律**：正常情况下每个周期 +4（字对齐）
- **分支跳转**：
  - 循环时跳转到 0x00000020（LOOP 标签）
  - 结束时跳转到 0x00000050（END 标签）

#### 9.3.2 寄存器值变化

- **$t0**：0 → 1 → 1 → 2 → 3 → 5 → 8 → 13 → 21
- **$t1**：1 → 1 → 2 → 3 → 5 → 8 → 13 → 21 → 34
- **$t2**：1 → 2 → 3 → 5 → 8 → 13 → 21 → 34 → 55
- **$t3**：2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 10

#### 9.3.3 内存数据验证

- 地址 0x100-0x124 存储 10 个斐波那契数
- 每个值按预期逐步计算并存储

#### 9.3.4 控制信号验证

- `reg_write`：大部分指令为 1（除了 sw, beq, j）
- `mem_write`：只在 sw 指令时为 1
- `branch`：只在 beq 指令时为 1
- `jump`：只在 j 指令时为 1

### 9.4 验证检查清单

- [x] PC 从 0x00000000 开始，逐步递增
- [x] 指令正确从指令存储器读取
- [x] 控制信号根据指令类型正确生成
- [x] 寄存器文件正确读写
- [x] ALU 正确执行运算
- [x] 数据存储器正确存储斐波那契数列
- [x] 分支指令正确跳转
- [x] 跳转指令正确执行
- [x] 计算结果正确（0, 1, 1, 2, 3, 5, 8, 13, 21, 34）

---

## 10. 项目总结

### 10.1 设计亮点

1. **模块化设计**：8 个独立模块，结构清晰，易于维护
2. **完整的指令支持**：支持 10 条 MIPS32 指令，涵盖 R-type、I-type、J-type
3. **标准数据通路**：实现了经典的五级数据通路（IF、ID、EX、MEM、WB）
4. **完善的测试**：斐波那契数列程序验证了 CPU 的各项功能
5. **详细的文档**：提供了完整的设计文档和使用说明

### 10.2 技术难点与解决方案

#### 难点 1：控制信号生成

- **问题**：需要根据不同的指令类型生成正确的控制信号
- **解决方案**：使用 case 语句根据 opcode 生成控制信号，并设计 ALU 控制单元处理 R-type 指令

#### 难点 2：数据通路连接

- **问题**：多个模块之间的信号连接复杂，容易出错
- **解决方案**：采用模块化设计，在顶层模块中统一连接，使用清晰的信号命名

#### 难点 3：分支和跳转逻辑

- **问题**：PC 更新需要处理顺序执行、分支和跳转三种情况
- **解决方案**：使用多路选择器（MUX）根据控制信号选择正确的 PC 下一个值

### 10.3 项目成果

- ✅ 完成了单周期 MIPS32 CPU 设计
- ✅ 支持 10 条指令，满足课程要求
- ✅ 成功运行斐波那契数列测试程序
- ✅ 通过仿真验证，结果正确
- ✅ 代码结构清晰，注释完整
- ✅ 提供了完整的设计文档

### 10.4 可能的扩展方向

1. **指令扩展**：

   - 支持更多指令（如 slti, bne, jal, jr 等）
   - 支持乘除法指令
   - 支持浮点运算指令

2. **性能优化**：

   - 实现多周期 CPU
   - 实现流水线 CPU
   - 添加缓存机制

3. **功能增强**：

   - 支持中断和异常处理
   - 添加调试接口
   - 支持多核设计

4. **应用扩展**：
   - 实现更复杂的测试程序
   - 支持操作系统运行
   - 实现外设接口

### 10.5 学习收获

1. **深入理解 CPU 工作原理**：从指令执行到数据通路的完整理解
2. **掌握 Verilog HDL 设计**：模块化设计、时序逻辑、组合逻辑的应用
3. **熟悉 FPGA 开发流程**：从设计到仿真到综合的完整流程
4. **提升系统设计能力**：从模块设计到系统集成的能力提升

---

## 附录：PPT 制作建议

### 幻灯片结构建议

1. **封面**：项目名称、作者、日期
2. **目录**：PPT 大纲
3. **项目概述**：背景、目标、特点
4. **设计目标**：课程要求、技术指标
5. **CPU 架构**：单周期原理、五个阶段
6. **模块划分**：8 个模块的功能说明（可分多页）
7. **模块关系图**：展示模块间的连接关系（重点）
8. **指令集**：10 条指令的详细说明
9. **数据通路**：五个阶段的详细说明
10. **测试程序**：斐波那契数列算法和实现
11. **仿真结果**：控制台输出、波形图截图
12. **项目总结**：亮点、难点、成果、扩展方向

### 图表制作建议

1. **模块关系图**：

   - 使用层次结构图展示模块依赖关系
   - 使用流程图展示数据流向
   - 使用信号连接图展示控制信号流向

2. **数据通路图**：

   - 使用五级流水线图展示指令执行流程
   - 使用数据流图展示关键数据通路

3. **波形图截图**：
   - 展示 PC 变化
   - 展示寄存器值变化
   - 展示内存数据变化
   - 展示控制信号变化

---

## 总体总结

本项目成功实现了一个基于 MIPS32 精简指令集的单周期 CPU，通过模块化设计将复杂的 CPU 系统分解为 8 个功能明确的子模块，实现了从指令取指到写回的完整数据通路。项目支持 10 条 MIPS32 指令，涵盖了 R-type、I-type 和 J-type 三种指令类型，能够正确执行斐波那契数列计算程序，并通过仿真验证了设计的正确性。

在设计过程中，我们深入理解了 CPU 的工作原理，掌握了 Verilog HDL 硬件描述语言的使用，熟悉了 FPGA 开发的完整流程。通过解决控制信号生成、数据通路连接、分支跳转逻辑等关键技术难点，提升了系统设计和调试能力。

本项目不仅满足了课程设计的基本要求，还为后续的性能优化和功能扩展奠定了基础。通过本次设计，我们不仅掌握了单周期 CPU 的实现方法，也为理解更复杂的多周期 CPU 和流水线 CPU 架构打下了坚实的基础。

---

**文档版本**：1.0  
**创建日期**：2025-12-07  
**用途**：PPT 制作大纲和模块关系说明
