# 斐波那契数列运行指标观察指南

## 一、概述

本文档指导如何在仿真波形中观察和验证斐波那契数列程序的正确执行，以及需要关注的关键指标。

## 二、关键观察指标

### 2.1 程序计数器（PC）

**信号名称**：`pc_out` 或 `uut.pc_current`

**观察要点**：

- **初始值**：复位后 PC 应为 0x00000000
- **递增规律**：正常情况下每个周期 +4（字对齐）
- **分支跳转**：
  - 循环时跳转到 0x00000020（LOOP 标签）
  - 结束时跳转到 0x00000050（END 标签）
- **关键地址**：
  - 0x00-0x1C：初始化阶段
  - 0x20-0x44：循环体（重复执行 8 次）
  - 0x48-0x50：结束阶段
  - 0x50：无限循环（程序停止）

**预期行为**：

```
PC 变化序列：
0x00 → 0x04 → 0x08 → ... → 0x1C → 0x20 → 0x24 → ... → 0x44 → 0x20 (循环)
最终停在 0x50 或 0x54（无限循环）
```

---

### 2.2 寄存器值变化

#### 2.2.1 斐波那契数寄存器

**$t0 (registers[8])**：前前一个斐波那契数

- 初始值：0
- 变化：0 → 1 → 1 → 2 → 3 → 5 → 8 → 13 → 21

**$t1 (registers[9])**：前一个斐波那契数

- 初始值：1
- 变化：1 → 1 → 2 → 3 → 5 → 8 → 13 → 21 → 34

**$t2 (registers[10])**：当前斐波那契数

- 在循环中计算：$t2 = $t0 + $t1
- 变化：1 → 2 → 3 → 5 → 8 → 13 → 21 → 34 → 55

#### 2.2.2 控制寄存器

**$t3 (registers[11])**：循环计数器

- 初始值：2
- 变化：2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 10
- 作用：控制循环次数

**$t4 (registers[12])**：循环上限

- 固定值：10
- 作用：与 $t3 比较判断是否结束循环

**$t5 (registers[13])**：内存地址偏移

- 初始值：8
- 变化：8 → 12 → 16 → 20 → 24 → 28 → 32 → 36 → 40
- 作用：计算数据存储地址

**$s0 (registers[16])**：基地址

- 固定值：0x100 (256)
- 作用：数据存储的基地址

---

### 2.3 内存数据

**观察信号**：`uut.u_dmem.mem[64]` 到 `uut.u_dmem.mem[73]`

**地址映射**：

- mem[64] = 地址 0x100 = fib[0]
- mem[65] = 地址 0x104 = fib[1]
- mem[66] = 地址 0x108 = fib[2]
- ...
- mem[73] = 地址 0x124 = fib[9]

**预期结果**：

| 内存索引 | 物理地址 | 斐波那契索引 | 预期值 | 写入时刻（约） |
| -------- | -------- | ------------ | ------ | -------------- |
| mem[64]  | 0x100    | fib[0]       | 0      | 初始化阶段     |
| mem[65]  | 0x104    | fib[1]       | 1      | 初始化阶段     |
| mem[66]  | 0x108    | fib[2]       | 1      | 第 1 次循环    |
| mem[67]  | 0x10C    | fib[3]       | 2      | 第 2 次循环    |
| mem[68]  | 0x110    | fib[4]       | 3      | 第 3 次循环    |
| mem[69]  | 0x114    | fib[5]       | 5      | 第 4 次循环    |
| mem[70]  | 0x118    | fib[6]       | 8      | 第 5 次循环    |
| mem[71]  | 0x11C    | fib[7]       | 13     | 第 6 次循环    |
| mem[72]  | 0x120    | fib[8]       | 21     | 第 7 次循环    |
| mem[73]  | 0x124    | fib[9]       | 34     | 第 8 次循环    |

---

### 2.4 ALU 运算结果

**信号名称**：`alu_result` 或 `uut.alu_out`

**观察要点**：

- **加法运算**：在循环中计算 fib[n] = fib[n-1] + fib[n-2]
- **减法运算**：计算 $t4 - $t3 判断循环是否结束
- **地址计算**：$s0 + $t5 计算存储地址

**关键时刻的 ALU 结果**：

- 第 1 次循环：0 + 1 = 1
- 第 2 次循环：1 + 1 = 2
- 第 3 次循环：1 + 2 = 3
- 第 4 次循环：2 + 3 = 5
- 第 5 次循环：3 + 5 = 8
- 第 6 次循环：5 + 8 = 13
- 第 7 次循环：8 + 13 = 21
- 第 8 次循环：13 + 21 = 34

---

### 2.5 控制信号

#### 2.5.1 寄存器写使能（reg_write）

**观察要点**：

- 大部分指令都会写寄存器（除了 sw, beq, j）
- 在 sw 指令时应为 0
- 在 beq 指令时应为 0
- 在 j 指令时应为 0

#### 2.5.2 内存写使能（mem_write）

**观察要点**：

- 只在 sw 指令时为 1
- 每次循环应该有一次内存写入
- 初始化阶段有 2 次内存写入（存储 fib[0] 和 fib[1]）

#### 2.5.3 分支信号（branch 和 pc_src）

**观察要点**：

- beq 指令时 branch = 1
- 当 $t7 != 0 时，pc_src = 0（不跳转，继续循环）
- 当 $t7 == 0 时，pc_src = 1（跳转到 END）

#### 2.5.4 跳转信号（jump）

**观察要点**：

- 只在 j 指令时为 1
- 循环回跳时出现（地址 0x44）
- 程序结束时出现（地址 0x50）

---

## 三、GTKWave 波形观察步骤

### 3.1 打开波形文件

```bash
gtkwave cpu_test.vcd
```

### 3.2 添加关键信号

在左侧信号树中依次展开并添加以下信号到波形窗口：

**1. 基本信号**

- `testbench.clk` - 时钟信号
- `testbench.rst` - 复位信号
- `testbench.pc_out` - 程序计数器

**2. 指令和控制**

- `testbench.uut.instruction` - 当前指令
- `testbench.uut.opcode` - 操作码
- `testbench.uut.reg_write` - 寄存器写使能
- `testbench.uut.mem_write` - 内存写使能

**3. 寄存器（展开 u_regfile.registers）**

- `registers[8]` - $t0
- `registers[9]` - $t1
- `registers[10]` - $t2
- `registers[11]` - $t3
- `registers[12]` - $t4
- `registers[13]` - $t5
- `registers[16]` - $s0

**4. ALU**

- `testbench.uut.alu_out` - ALU 结果
- `testbench.uut.alu_zero` - 零标志

**5. 内存（展开 u_dmem.mem）**

- `mem[64]` 到 `mem[73]` - 斐波那契数列存储位置

### 3.3 设置显示格式

- **PC、地址、指令**：右键 → Data Format → Hexadecimal
- **寄存器值、内存值**：右键 → Data Format → Decimal（或 Unsigned Decimal）
- **控制信号**：保持 Binary 格式

### 3.4 关键时间点定位

使用 GTKWave 的搜索功能定位关键事件：

1. **程序开始**：rst 下降沿后的第一个时钟周期
2. **初始化完成**：PC = 0x20 时
3. **第一次循环**：PC 从 0x20 开始
4. **循环结束**：PC 跳转到 0x48 时
5. **程序停止**：PC 停在 0x50 或 0x54

---

