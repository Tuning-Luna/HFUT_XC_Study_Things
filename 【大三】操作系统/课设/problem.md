# 1. 课程设计任务、要求、目的

## 1.1 课程设计任务

依据操作系统课程所介绍的多线程同步机制，设计和实现一个读者-写者问题的多线程程序。该系统需要正确处理多个读者线程和写者线程对共享资源的并发访问，确保数据的一致性和线程安全。

## 1.2 课程设计目的和要求

系统应该包含两个部分：一个部分是按内核代码原则设计的读者-写者同步机制，由一系列的函数组成；另一个部分是演示系统，调用同步机制的相应函数，以让其运行，同时提供系统的展示界面（字符界面），以展示系统的运行状态，显示系统的关键数据结构的内容。

具体包括：

- 设置两类线程，一类为读者，一类为写者
- 使用菜单方式启动读者或写者（通过键盘输入'r'创建读者，'w'创建写者）
- 在窗口上显示读者或写者执行状态
- 随着线程的执行，实时更新窗口的显示，包括当前读者数量、共享数据值等
- 实现读者优先的同步机制，确保多个读者可以同时读取，但写者必须独占访问

# 2. 开发环境

- **操作系统**：Linux/Unix 系统（支持 POSIX 线程）
- **编程语言**：C 语言
- **编译器**：GCC (GNU Compiler Collection)
- **开发工具**：支持 POSIX 线程库的开发环境
- **编译命令**：`gcc -o os_2 os_2.c -lpthread`
- **运行环境**：Linux 终端或支持 POSIX 线程的 Unix-like 系统

# 3. 相关原理及算法

## 3.1 读者-写者问题

读者-写者问题是一个经典的进程同步问题，描述如下：

- 多个读者线程可以同时读取共享数据
- 写者线程必须独占访问共享数据（不能与读者或其他写者同时访问）
- 当有读者正在读取时，写者必须等待
- 当有写者正在写入时，读者必须等待

## 3.2 读者优先算法

本系统采用读者优先（Reader-Preference）策略：

- 第一个读者到达时，获取写锁，阻止写者访问
- 后续读者可以直接进入，只需增加读者计数
- 最后一个读者离开时，释放写锁，允许写者访问
- 写者必须等待所有读者完成才能访问

## 3.3 同步机制

- **信号量（Semaphore）**：用于控制写者的访问权限，确保写者独占访问
- **互斥锁（Mutex）**：用于保护读者计数器的临界区，确保读者计数的原子性操作

# 4. 系统结构和主要的算法设计思路

## 4.1 系统架构

系统采用模块化设计，主要包含以下模块：

1. **主控制模块（main 函数）**：负责系统初始化、菜单显示、线程创建和资源清理
2. **读者线程模块（reader 函数）**：实现读者的同步访问逻辑
3. **写者线程模块（writer 函数）**：实现写者的同步访问逻辑
4. **状态显示模块（show_status 函数）**：实时显示线程执行状态

## 4.2 算法设计思路

### 读者算法流程：

1. 获取互斥锁，保护读者计数器
2. 读者计数加 1
3. 如果是第一个读者（read_count == 1），获取写锁（sem_wait），阻止写者
4. 释放互斥锁
5. 执行读取操作（模拟耗时 2 秒）
6. 获取互斥锁
7. 读者计数减 1
8. 如果是最后一个读者（read_count == 0），释放写锁（sem_post），允许写者
9. 释放互斥锁

### 写者算法流程：

1. 等待获取写锁（sem_wait），确保独占访问
2. 执行写入操作（修改共享数据，模拟耗时 3 秒）
3. 释放写锁（sem_post）

### 关键设计点：

- 使用互斥锁保护读者计数器的临界区，避免竞态条件
- 使用信号量实现写者的互斥访问
- 第一个读者获取写锁，最后一个读者释放写锁，实现读者优先策略

# 5. 程序实现——主要数据结构

## 5.1 同步原语

```c
sem_t db_write_lock;        // 数据库写锁（信号量），控制写者的访问权限
pthread_mutex_t mutex;      // 互斥锁，保护读者计数器的临界区
```

## 5.2 共享变量

```c
int read_count = 0;         // 正在读取的读者数量计数器
int shared_data = 0;        // 共享数据，读者读取、写者修改的对象
```

## 5.3 线程参数

```c
int* id;                    // 动态分配的线程ID，传递给线程函数
pthread_t tid;              // 线程标识符
```

## 5.4 数据结构说明

- **db_write_lock**：信号量，初始值为 1，用于实现写者的互斥访问。当值为 0 时，表示有读者正在访问，写者必须等待。
- **mutex**：互斥锁，用于保护 read_count 变量的访问，确保读者计数的原子性操作。
- **read_count**：记录当前正在读取的读者数量，用于判断是否为第一个或最后一个读者。
- **shared_data**：模拟的共享数据，读者读取其值，写者修改其值（递增）。

# 6. 程序实现——程序实现细节描述

## 6.1 状态显示函数（show_status）

该函数用于实时显示线程的执行状态，包括角色（读者/写者）、线程 ID、执行动作、当前读者数量和共享数据值。

```c
void show_status(const char* role, int id, const char* action) {
    printf(">> [%s-%d] %s (当前读者数: %d, 数据值: %d)\n",
           role, id, action, read_count, shared_data);
}
```

## 6.2 读者线程函数（reader）

读者线程的实现遵循读者优先策略：

1. **进入阶段**：

   - 获取互斥锁保护读者计数器
   - 读者计数加 1
   - 如果是第一个读者，获取写锁（阻止写者）
   - 释放互斥锁

2. **读取阶段**：

   - 显示开始读取状态
   - 模拟读取操作（sleep 2 秒）
   - 显示读取完成状态

3. **离开阶段**：
   - 获取互斥锁保护读者计数器
   - 读者计数减 1
   - 如果是最后一个读者，释放写锁（允许写者）
   - 释放互斥锁

## 6.3 写者线程函数（writer）

写者线程的实现确保独占访问：

1. **等待阶段**：

   - 显示等待写入权限状态
   - 等待获取写锁（sem_wait），阻塞直到获得访问权限

2. **写入阶段**：

   - 修改共享数据（shared_data++）
   - 显示正在修改数据状态
   - 模拟写入操作（sleep 3 秒）
   - 显示写入完成状态

3. **释放阶段**：
   - 释放写锁（sem_post），允许其他线程访问

## 6.4 主函数（main）

主函数负责系统初始化和用户交互：

1. **初始化阶段**：

   - 初始化信号量（db_write_lock，初始值为 1）
   - 初始化互斥锁（mutex）

2. **菜单循环**：

   - 显示操作菜单
   - 等待用户输入（'r'创建读者，'w'创建写者，'q'退出）
   - 动态分配线程 ID
   - 创建对应的线程（读者或写者）
   - 使用 pthread_detach 使线程分离，自动回收资源

3. **清理阶段**：
   - 销毁信号量和互斥锁
   - 退出程序

## 6.5 关键实现细节

- **线程 ID 传递**：使用动态内存分配（malloc）为每个线程分配独立的 ID，避免线程间 ID 冲突
- **线程分离**：使用 pthread_detach 使线程在结束后自动回收资源，无需主线程等待
- **同步机制**：通过信号量和互斥锁的组合使用，实现了读者优先的同步策略

# 7.程序运行的主要界面和实验结果截图

## 7.1 程序启动界面

程序启动后显示操作菜单：

```
   读者-写者
'r' 启动一个读者
'w' 启动一个写者
'q' 退出程序
==============================
```

## 7.2 运行示例

### 示例 1：多个读者同时读取

用户输入多个'r'创建读者线程，可以看到多个读者可以同时读取：

```
> 指令: 创建读者 1
>> [读者-1] 开始读取... (当前读者数: 1, 数据值: 0)
> 指令: 创建读者 2
>> [读者-2] 开始读取... (当前读者数: 2, 数据值: 0)
>> [读者-1] 读取完成 (当前读者数: 1, 数据值: 0)
>> [读者-2] 读取完成 (当前读者数: 0, 数据值: 0)
```

### 示例 2：写者独占访问

用户输入'w'创建写者线程，写者会等待所有读者完成后才执行：

```
> 指令: 创建写者 1
>> [写者-1] 等待写入权限... (当前读者数: 1, 数据值: 0)
>> [读者-1] 读取完成 (当前读者数: 0, 数据值: 0)
>> [写者-1] 正在修改数据 (当前读者数: 0, 数据值: 1)
>> [写者-1] 写入完成，离开 (当前读者数: 0, 数据值: 1)
```

### 示例 3：读者优先策略验证

当有读者正在读取时，写者必须等待；当有写者正在写入时，读者必须等待：

```
> 指令: 创建读者 1
>> [读者-1] 开始读取... (当前读者数: 1, 数据值: 0)
> 指令: 创建写者 1
>> [写者-1] 等待写入权限... (当前读者数: 1, 数据值: 0)
> 指令: 创建读者 2
>> [读者-2] 开始读取... (当前读者数: 2, 数据值: 0)
>> [读者-1] 读取完成 (当前读者数: 1, 数据值: 0)
>> [读者-2] 读取完成 (当前读者数: 0, 数据值: 0)
>> [写者-1] 正在修改数据 (当前读者数: 0, 数据值: 1)
>> [写者-1] 写入完成，离开 (当前读者数: 0, 数据值: 1)
```

## 7.3 实验结果分析

1. **读者并发性**：多个读者可以同时读取，验证了读者优先策略的正确实现
2. **写者互斥性**：写者必须等待所有读者完成后才能访问，确保了数据一致性
3. **同步机制有效性**：通过信号量和互斥锁，成功避免了竞态条件和数据竞争
4. **实时状态显示**：系统能够实时显示线程执行状态和共享数据的变化

# 8. 总结和感想体会

## 8.1 总结

本次课程设计成功实现了一个基于读者-写者问题的多线程同步程序。系统采用读者优先策略，使用信号量和互斥锁实现了正确的同步机制。通过字符界面的菜单系统，用户可以动态创建读者和写者线程，并实时观察线程的执行状态和共享数据的变化。

系统的主要特点：

- 正确实现了读者-写者问题的同步机制
- 支持多个读者并发读取
- 确保写者独占访问共享数据
- 提供实时状态显示功能
- 代码结构清晰，易于理解和维护

## 8.2 感想体会

通过本次课程设计，我深入理解了多线程编程和进程同步机制：

1. **同步原语的重要性**：信号量和互斥锁是多线程编程中不可或缺的工具，正确使用它们可以避免竞态条件和数据竞争，确保程序的正确性。

2. **读者-写者问题的复杂性**：虽然问题描述简单，但实际实现需要考虑多种边界情况，如第一个读者和最后一个读者的特殊处理，以及读者优先和写者优先两种策略的区别。

3. **调试多线程程序的挑战**：多线程程序的调试比单线程程序更加困难，因为线程的执行顺序是不确定的，需要仔细设计同步机制来保证程序的正确性。

4. **理论与实践的结合**：通过实际编程实现，我更好地理解了操作系统课程中关于进程同步的理论知识，加深了对信号量、互斥锁等概念的理解。

5. **代码设计的重要性**：良好的代码结构可以提高程序的可读性和可维护性，模块化的设计使得程序更容易理解和扩展。

本次课程设计不仅提高了我的编程能力，也加深了我对操作系统原理的理解，为后续的学习和工作打下了良好的基础。

# 参考文献

[1] 汤小丹, 梁红兵, 哲凤屏, 等. 计算机操作系统[M]. 4 版. 西安: 西安电子科技大学出版社, 2014.

[2] Abraham Silberschatz, Peter Baer Galvin, Greg Gagne. 操作系统概念[M]. 9 版. 北京: 高等教育出版社, 2013.

[3] W. Richard Stevens, Stephen A. Rago. UNIX 环境高级编程[M]. 3 版. 北京: 人民邮电出版社, 2014.

[4] POSIX Threads Programming[EB/OL]. https://computing.llnl.gov/tutorials/pthreads/, 2024.

[5] Butenhof D R. Programming with POSIX threads[M]. Boston: Addison-Wesley Professional, 1997.

附录 1：程序清单(部分)

## 核心数据结构定义

```c
sem_t db_write_lock;        // 数据库写锁
pthread_mutex_t mutex;      // 互斥锁
int read_count = 0;         // 正在读的读者数量
int shared_data = 0;        // 共享数据
```

## 读者线程函数

```c
void* reader(void* arg) {
    int id = *(int*)arg;
    free(arg);

    // 申请进入
    pthread_mutex_lock(&mutex);
    read_count++;
    if (read_count == 1) {
        sem_wait(&db_write_lock); // 第一个读者锁住写者
    }
    pthread_mutex_unlock(&mutex);

    // 执行读取
    show_status("读者", id, "开始读取...");
    sleep(2);
    show_status("读者", id, "读取完成");

    // 离开
    pthread_mutex_lock(&mutex);
    read_count--;
    if (read_count == 0) {
        sem_post(&db_write_lock); // 最后一个读者释放写者
    }
    pthread_mutex_unlock(&mutex);

    return NULL;
}
```

## 写者线程函数

```c
void* writer(void* arg) {
    int id = *(int*)arg;
    free(arg);

    show_status("写者", id, "等待写入权限...");
    sem_wait(&db_write_lock);  // 申请独占写入

    shared_data++; // 修改数据
    show_status("写者", id, "正在修改数据");
    sleep(3);
    show_status("写者", id, "写入完成，离开");

    sem_post(&db_write_lock);  // 释放锁
    return NULL;
}
```

## 主函数核心部分

```c
int main() {
    sem_init(&db_write_lock, 0, 1);
    pthread_mutex_init(&mutex, NULL);

    int id_counter = 1;
    char choice;

    while (1) {
        scanf(" %c", &choice);
        if (choice == 'q') break;

        int* id = malloc(sizeof(int));
        *id = id_counter++;
        pthread_t tid;

        if (choice == 'r') {
            pthread_create(&tid, NULL, reader, id);
            pthread_detach(tid);
        }
        else if (choice == 'w') {
            pthread_create(&tid, NULL, writer, id);
            pthread_detach(tid);
        }
    }

    sem_destroy(&db_write_lock);
    pthread_mutex_destroy(&mutex);
    return 0;
}
```

附录 2：

其余需要附上的数据、图表、截图等。可以没有.

# 我的任务：

多线程编程：读者-写者问题

- 设置两类线程，一类为读者，一类为写者
- 使用菜单随机启动读者或写者
- 在窗口上显示读者或写者执行状态
- 随着线程的执行，更新窗口的显示
