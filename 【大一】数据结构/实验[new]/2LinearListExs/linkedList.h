
//************************************************//
//*    单链表的头文件，文件名：linkedList.h      *//
//*    -- 此版本混合使用指针和引用               *//
//************************************************//



typedef int elementType;  //elementType 定义为整数类型

//************************************************//
//*          单链表的结构定义                    *//
//*   2个分量组成，data存放数据元素              *//
//*                next是指向下一个元素的指针    *//
//*   用typedef将其定义为数据类型node或node指针  *//
//*   有下面两种定义方式，结果相同               *//
//************************************************//
//链表定义--两种定义方式相同
//单链表定义方式一
typedef struct LNode
{
	elementType data;
	struct LNode *next;
} node, *linkedList; 

//单链表定义方式二
/*
struct LNode
{
	elementType data;
	struct LNode *next;
};

//typedef struct LNode node, *linkedList; 
typedef LNode node, *linkedList; 
*/

typedef struct BLNode
{
	elementType data;
	struct BLNode *prior, *next;
}BNode, *BLinkedList; 


BNode* createListBLR()
{
	elementType x; //数据元素的数值
	BNode *BL, *p; //BL为头节点指针

	BL=new BNode;  //产生头节点，动态的在heap上申请内存，存放一个节点（头结点）
	BL->prior=BL;
	BL->next=BL;  


	cout<<"请输入元素数据（整数，9999退出）:"<<endl;
	cin>>x;	
	while(x!=9999)
	{   
		p=new BNode;  //动态申请内存，产生新节点

		p->data=x;  //写入元素数据
		
		p->next=BL;  //原来尾节点的next指向新节点p
		p->prior=BL->prior;
		BL->prior=p;        //修改尾指针，使得指向最新产生的节点，即后移一个节点
		
		cin>>x;
	}

	p=NULL;

	return BL; //返回头结点指针，即整个链表

}



/*---------------------------------------------------------------*/
//************************************************//
//* 1. 单链表初始化--创建只有头结点的空表        *//
//*    本组算法中提供3种初始化实现：             *//
//*       --引用、双指针、函数值返回创建的空表   *//
//*    实验了单指针不能传递                      *//
//************************************************//

//(1.1) 引用实现--c++适用
//**********************************************************//
//* 函数功能：初始化单链表--创建只有头结点的空表           *//
//*           利用“引用”从子函数向主调函数传递创建的空表 *//
//* 函数参数：node指针的引用，引用头结点指针               *//
//* 返 回 值：空                                           *//
//* 文 件 名：linkedList.h  函 数 名：initialList          *//
//**********************************************************//
void initialList(node *& L)
{
cout<<"  子函数申请头节点前：L="<<L<<endl;

	L=new node; //动态在heap上申请内存，保存节点（头结点）
	            //new 申请内存，返回的是node空间的指针
	L->next=NULL;

cout<<"  子函数申请头节点后：L="<<L<<endl;
}

//(1.2) 指针的指针实现--c和c++适用
//************************************************************//
//* 函数功能：初始化单链表--创建只有头结点的空表             *//
//*           利用“指针的指针”从子函数向主函数传递链表     *//
//* 函数参数：node型指针的的指针，即指向头结点指针的指针     *//
//* 返 回 值：空                                             *//
//* 文 件 名：linkedList.h  函 数 名：initialList1           *//
//************************************************************//
void initialList1( node** A ) //A 为指向node型节点的指针的指针
{
cout<<"  子函数申请头节点前：L="<<(*A)<<endl;

	(*A)=new node;  //(*A)为指向node型节点的指针
	                //动态在heap上申请内存，保存节点（头结点）
	(*A)->next=NULL;
cout<<"  子函数申请头节点后：L="<<(*A)<<endl;

} 

//(1.3) 函数返回值实现
//************************************************************//
//* 函数功能：初始化单链表--创建只有头结点的空表             *//
//*           利用函数返回值返回子函数创建的链表             *//
//* 函数参数：空                                             *//
//* 返 回 值：node*类型，即结点指针                          *//
//* 文 件 名：linkedList.h  函 数 名：initialList2           *//
//************************************************************//
node* initialList2()
{
	node* P;
	P=new node;
	P->next=NULL;

cout<<"  子函数申请头节点后：P="<<P<<endl;
	return P;

}

//（1.4）单指针不能传回链表实验
//************************************************************//
//* 情况说明：子函数中创建了单链表，但不能传递到主函数       *//
//*            因为要在创建子函数中动态申请内存，            *//
//*            造成实参的节点指针和形参的指针数值不同,       *//
//*            实参和形参指针将指向heap中的不同位置，        *//
//*            子函数返回时，不能向主调函数传递创建的链表。  *//
//*            且，此种情况会造成内存泄漏（memory leak）     *//
//* 函数参数：node指针                                       *//
//* 返 回 值：空                                             *//
//* 文 件 名：linkedList.h  函 数 名：initialListTest        *//
//************************************************************//
void initialListTest(node* pL)
{
cout<<"  子函数申请头节点前：pL="<<pL<<endl;

	pL=new node; //动态在heap上申请内存，保存节点（头结点）
	pL->next=NULL;

cout<<"  子函数申请头节点后：pL="<<pL<<endl;
}

/*---------------------------------------------------------------*/
//************************************************//
//* 2.求链表的长度--求元素节点的个数，不含头结点 *//
//*    本组算法中提供3种初始化实现：             *//
//*       --引用、双指针、函数值返回单链表长度   *//
//*    实验了单指针不能传递                      *//
//************************************************//

//(2.1) 函数返回值返回单链表长度
//************************************************************//
//* 函数功能：求表长度，利用函数返回值向主函数传递链表长度   *//
//* 输入参数：node* pL                                       *//
//* 输出参数：空                                             *//
//* 返 回 值：int型，链表长度                                *//
//* 文 件 名：linkedList.h  函 数 名：listLength             *//
//************************************************************//
int listLength(node* pL)
{
	int len=0; //保存长度值
	node *p=pL->next;  //p指向头结点后面一个节点，即第一个元素节点
	while(p!=NULL)
	{		
		p=p->next; //p的指向后移一个节点
		len++; //p!=NULL说明存在元素节点，计数加1		
	}
	return len;  //返回总计数值，即长度
}
//问题：--可以用指针和引用来返回长度值吗？如何实现呢？
//先移动后计数
int listLength1(node* pL)
{
	int len=0; //保存长度值
	node *p=pL;  //pL指向头结点
	while(p->next!=NULL)
	{		
		len++;     //p!=NULL说明存在元素节点，计数加1
		p=p->next; //p的指向后移一个节点		
	}
	return len;  //返回总计数值，即长度
}


//(2.3) 利用“引用”返回表长度
//************************************************************//
//* 函数功能：求表长度，利用“引用”向主函数传递链表长度     *//
//* 输入参数：node* pL                                       *//
//* 输出参数：int型变量的引用len1                            *//
//* 返 回 值：空                                             *//
//* 文 件 名：linkedList.h  函 数 名：listLength1            *//
//************************************************************//
void listLength2(node* L, int & len1)
{
	len1=0; //保存长度值
	node *p=L->next;  //p指向头结点后面一个节点，即第一个元素节点
	while(p!=NULL)
	{
		len1++; //p!=NULL说明存在元素节点，计数加1
		p=p->next; //p的指向后移一个节点
	}
	
}

//(2.3) “指针”返回链表长度
//************************************************************//
//* 函数功能：求表长度，利用“指针”向主函数传递链表长度     *//
//* 输入参数：node* pL                                       *//
//* 输出参数：int型变量的指针len1                            *//
//* 返 回 值：空                                             *//
//* 文 件 名：linkedList.h  函 数 名：listLength2            *//
//************************************************************//
void listLength2(node* pL, int* len1)
{
	(*len1)=0; //保存长度值
	node *p=pL->next;  //p指向头结点后面一个节点，即第一个元素节点
	while(p!=NULL)
	{
		(*len1)++; //p!=NULL说明存在元素节点，计数加1
		p=p->next; //p的指向后移一个节点
	}
}

//**问题：--本函数的形参pL为什么可以用单指针呢？使用“引用”是否可行？传值是否可以？


/*---------------------------------------------------------------*/
//************************************************//
//* 3.按序号求元素--求指定编号的元素节点         *//
//*    本组算法中提供3种方式实现：               *//
//*      --指针的引用、双指针、函数值返回目标结点*//
//************************************************//

//(3.1) 用函数返回值返回目标结点指针
//************************************************************//
//* 函数功能：序号求元素，利用函数返回值向主函数传递目标结点 *//
//*           目标结点存在：返回结点指针；否则返回空指针     *//
//* 输入参数：node* pL, int i                                *//
//* 输出参数：空                                             *//
//* 返 回 值：node*，目标结点指针，或空指针                  *//
//* 文 件 名：linkedList.h  函 数 名：getElement             *//
//************************************************************//
node* getElement(node *L, int i)
{
	node* p=L->next;
	int j=1;
	while((j!=i) && (p!=NULL))  //当前节点不是目标节点，有不为空，继续处理下一个节点
	{
		p=p->next;
		j++;
	}

	return p; //当j=i时，p为目标节点；否则p=NULL，目标不存在
}

//(3.2) 用指针参数*p的引用返回目标节点的指针
//************************************************************//
//* 函数功能：序号求元素，利用指针的引用向主函数传递目标结点 *//
//*           目标结点存在：返回结点指针；否则返回空指针     *//
//* 输入参数：node* pL, int i                                *//
//* 输出参数：node* &p1，返回目标结点指针                    *//
//* 返 回 值：空                                             *//
//* 文 件 名：linkedList.h  函 数 名：getElement1            *//
//************************************************************//
void getElement1(node *L,int i, node* &p1)
{
	int j=1;
	p1=L->next;
	while((j!=i) && (p1!=NULL))  //当前节点不是目标节点，有不为空，继续处理下一个节点
	{
		p1=p1->next;
		j++;
	}
}

//(3.3) 用指针的指针参数返回目标节点指针
//************************************************************//
//* 函数功能：序号求元素，利用双指针向主函数传递目标结点指针 *//
//*           目标结点存在：返回结点指针；否则返回空指针     *//
//* 输入参数：node* pL, int i                                *//
//* 输出参数：node** p2，返回目标结点指针                    *//
//* 返 回 值：空                                             *//
//* 文 件 名：linkedList.h  函 数 名：getElement2            *//
//************************************************************//
void getElement2(node *L, int i, node** p2)
{
	int j=1;
	(*p2)=L->next; //(*p2)为node 指针
	while((j!=i) && ((*p2)!=NULL))  //当前节点不是目标节点，有不为空，继续处理下一个节点
	{
		(*p2)=(*p2)->next;
		j++;
	}
}

/*---------------------------------------------------------------*/
//***********************************************************//
//* 4. 定位元素 x，返回目标节点指针和序号                   *//
//*    本组算法中提供4种方式实现：（还有更多方法）          *//
//*      --指针的引用、双指针、函数值等返回目标结点         *//
//***********************************************************//

//(4.1) 函数返回值返回目标指针，指针参数返回序号
//************************************************************//
//* 函数功能：表中定位x元素，函数值返回目标结点；指针返回编号*//
//*           目标结点不存在：返回空指针；序号为0            *//
//* 输入参数：node *L, elementType x,                        *//
//* 输出参数：int* j，返回目标结点编号，或0                  *//
//* 返 回 值：node*，目标结点指针，或空指针                  *//
//* 文 件 名：linkedList.h  函 数 名：listLocate             *//
//************************************************************//
node* listLocate(node *L, elementType x, int* j)
{
	node *p=L->next;
	(*j)=1;
	while((p!=NULL) && (p->data!=x))  
	{
		p=p->next;
		(*j)++;
	}

	if (p==NULL)  //如果p为空指针，元素x不在表中，(*j)=0
		(*j)=0;

	return p;
}  

//(4.2) 用引用返回元素位置
//************************************************************//
//* 函数功能：表中定位x元素，函数值返回目标结点；引用返回编号*//
//*           目标结点不存在：返回空指针；序号为0            *//
//* 输入参数：node *L, elementType x,                        *//
//* 输出参数：int& j，返回目标结点编号，或0                  *//
//* 返 回 值：node*，目标结点指针，或空指针                  *//
//* 文 件 名：linkedList.h  函 数 名：listLocate1            *//
//************************************************************//
node* listLocate1(node *L, elementType x, int& j )
{
	node *p=L->next;
	j=1;
	while((p!=NULL) && (p->data!=x))  
	{
		p=p->next;
		j++;
	}

	if (p==NULL)  //如果p为空指针，元素x不在表中，j=0
		j=0;

	return p;
}

//(4.3) 用函数值返回序号，引用返回指针
//************************************************************//
//* 函数功能：表中定位x元素，函数值返回目标元素编号；        *//
//*                          指针引用返回目标结点指针        *//
//*           目标结点不存在：返回空指针；序号为0            *//
//* 输入参数：node *L, elementType x,                        *//
//* 输出参数：node* &p，返回目标结点指针，或空指针           *//
//* 返 回 值：int，目标结点编号，或0                         *//
//* 文 件 名：linkedList.h  函 数 名：listLocate3            *//
//************************************************************//
int listLocate3(node *L, elementType x, node* &p)
{
    p=L->next;
	int j=1;
	while((p!=NULL) && (p->data!=x))  
	{
		p=p->next;
		j++;
	}

	if (p==NULL)  //如果p为空指针，元素x不在表中，j=0
		j=0;

	return j;
}

//(4.4) 目标节点指针和序号，都用引用返回
//************************************************************//
//* 函数功能：表中定位x元素，指针引用返回目标结点指针；      *//
//*                          引用返回目标编号                *//
//*           目标结点不存在：返回空指针；序号为0            *//
//* 输入参数：node *L, elementType x,                        *//
//* 输出参数：node* &p，目标结点指针；int &j 目标结点编号    *//
//* 返 回 值：空                                             *//
//* 文 件 名：linkedList.h  函 数 名：listLocate4            *//
//************************************************************//
void listLocate4(node *L, elementType x, node* &p, int &j)
{
    p=L->next;
	j=1;
	while((p!=NULL) && (p->data!=x))  
	{
		p=p->next;
		j++;
	}

	if (p==NULL)  //如果p为空指针，元素x不在表中，j=0
		j=0;
}

//还有其它实现方式吗？--回答是肯定的！


/*---------------------------------------------------------------*/
//***********************************************************//
//* //5. 插入算法                                           *//
//*    指定位置i，插入指定元素x                             *//
//*                                                         *//
//***********************************************************//

//************************************************************//
//* 函数功能：表中指定位置i插入x元素                         *//
//*           插入成功返回true；失败返回false                *//
//* 输入参数：node *L, elementType x,                        *//
//* 输出参数：int* j，返回目标结点编号，或0                  *//
//* 返 回 值：node*，目标结点指针，或空指针                  *//
//* 文 件 名：linkedList.h  函 数 名：listLocate             *//
//************************************************************//

bool listInsert(node* L, int i, elementType x )
{
	node* p=L;  //p指向头结点
	node* S;

	int k=0;

	while(k!=i-1 && p!=NULL)  //搜索ai-1节点，并取得指向ai的指针
	{
		p=p->next;  //p指向下一个节点
		k++; 
	}

	if(p==NULL)
		return false;  //p为空指针，说明插入位置 i不对，返回false
	else
	{
		//此时，k=i-1，p为a1-1节点的指针
		S=new node; //动态申请内存, 创建一个新节点，即：要插入的节点

		S->data=x; //装入数据
		S->next=p->next;
		p->next=S;

		return true;  //正确插入返回 true
	}
}

//问题：为什么单指针就可以呢？
//      还有其它实现方法吗？

/*---------------------------------------------------------------*/
//***********************************************************//
//* //6. 链表的删除算法                                     *//
//*      删除指定位置i的元素                                *//
//*                                                         *//
//***********************************************************//

//************************************************************//
//* 函数功能：删除表中指定位置i出的元素（结点）              *//
//*           插入成功返回true；失败返回false                *//
//* 输入参数：node* L,int i                                  *//
//* 输出参数：node* L，返回删除后的链表                      *//
//* 返 回 值：bool，删除成功true；失败false                  *//
//* 文 件 名：linkedList.h  函 数 名：listDelete             *//
//************************************************************//
bool listDelete(node* L,int i)
{
	node* u;
	node* p=L;  //指向头结点
	int k=0;
	while(k!=i-1 && p!=NULL)  //搜索ai-1节点
	{
		p=p->next;
		k++;
	}
	if(p==NULL || p->next==NULL)
		return false;  //删除位置 i 超出范围，删除失败，返回false
	else
	{
		//此时，p指向ai-1
		u=p->next;  //u指向待删除节点 a1
		p->next=u->next;  //ai-1的next指向ai+1节点，或为空（ai-1为最后节点）
		delete u;   //释放删除节点占据的控件，此句必须，否则这个节点的内存将称为垃圾内存

		return true; //成功删除，返回 true
	}
}

//问题：为什么单指针可以呢？
//      还有其它实现方法吗？

/*---------------------------------------------------------------*/
//7. 尾插法创建带头结点的链表
//用户从键盘输入节点个数
//用户从键盘输入节点元素数据
//新插入的节点位于链表最后
//分别使用指针的指针和C++的引用方式传回创建的链表

//(7.1) c++ 引用实现--利用引用从本函数向主调函数传递创建的链表
void createListR( node *& L )
{
	int i;
	int n; //元素节点个数，不含头结点
	elementType x; //数据元素的数值
	node *p, *R; //R为尾节点的指针

	L=new node;  //产生头节点，动态的在heap上申请内存，存放一个节点（头结点）
	L->next=NULL;  //头结点的指针域为空


	R=L;  //设置尾指针，对空表头、尾指针相同

	cout<<"请输入元素节点个数（整数）："<<endl;  //控制元素节点的个数
	cin>>n;

	cout<<"请输入元素数据（整数）:"<<endl;
	for(i=n;i>0;i--)  //尾插法循环插入节点
	{
		p=new node;  //动态申请内存，产生新节点
		cin>>x;

		p->data=x;  //写入元素数据
		
		R->next=p;  //原来尾节点的next指向新节点p
		R=p;        //修改尾指针，使得指向最新产生的节点，即后移一个节点
	}
	R->next=NULL;  //尾节点的next指针为空。

}


//(7.2) 指针的指针实现--利用指针的指针从本函数向主调函数传递创建的链表--c和c++适用
void createListR1( node** A ) //A为node型节点的指针的指针
{
	int i;
	int n; //元素节点个数，不含头结点
	elementType x; //数据元素的数值
	node *p, *R; //R为尾节点的指针

	(*A)=new node;  //产生头节点，动态的在heap上申请内存，存放一个节点（头结点）
	                //(*A) 为node型节点的指针，即与p和R类型相同
	(*A)->next=NULL;  //头结点的指针域为空

	R=(*A);  //设置尾指针，对空表头、尾指针相同

	cout<<"请输入元素节点个数（整数）："<<endl;  //控制元素节点的个数
	cin>>n;

	cout<<"请输入元素数据（整数）:"<<endl;
	for(i=n;i>0;i--)  //尾插法循环插入节点
	{
		p=new node;  //动态申请内存，产生新节点
		cin>>x;

		p->data=x;  //写入元素数据
		
		R->next=p;  //原来尾节点的next指向新节点p
		R=p;        //修改尾指针，使得指向最新产生的节点，即后移一个节点
	}
	R->next=NULL;  //尾节点的next指针为空。

}

//(7.3) 利用函数返回值返回创建的链表--返回值类型：节点指针类型
node* createListR2()
{
	int i;
	int n; //元素节点个数，不含头结点
	elementType x; //数据元素的数值
	node *H, *p, *R; //H为头节点指针，R为尾节点的指针

	H=new node;  //产生头节点，动态的在heap上申请内存，存放一个节点（头结点）
	H->next=NULL;  //头结点的指针域为空

	R=H;  //设置尾指针，对空表:头、尾指针相同

	cout<<"请输入元素节点个数（整数）："<<endl;  //控制元素节点的个数
	cin>>n;

	cout<<"请输入元素数据（整数）:"<<endl;
	for(i=n;i>0;i--)  //尾插法循环插入节点
	{
		p=new node;  //动态申请内存，产生新节点
		cin>>x;

		p->data=x;  //写入元素数据
		
		R->next=p;  //原来尾节点的next指向新节点p
		R=p;        //修改尾指针，使得指向最新产生的节点，即后移一个节点
	}
	R->next=NULL;  //尾节点的next指针为空。

	R=NULL;  //使2个指针什么也不指向
	p=NULL;

	return H; //返回头结点指针，即整个链表

}

//(7.4) 以“-9999”作为结束元素输入条件，用函数值返回链表
node* createListR3()
{
	elementType x; //数据元素的数值
	node *H, *p, *R; //H为头节点指针，R为尾节点的指针

	H=new node;  //产生头节点，动态的在heap上申请内存，存放一个节点（头结点）
	H->next=NULL;  //头结点的指针域为空

	R=H;  //设置尾指针，对空表:头、尾指针相同



	cout<<"请输入元素数据（整数，-9999退出）:"<<endl;
	cout<<"x=";
	cin>>x;
	
	while(x!=-9999)
	{   
		p=new node;  //动态申请内存，产生新节点

		p->data=x;  //写入元素数据
		
		R->next=p;  //原来尾节点的next指向新节点p
		R=p;        //修改尾指针，使得指向最新产生的节点，即后移一个节点
		
		cout<<"x=";
		cin>>x;
	}
	R->next=NULL;  //尾节点的next指针为空。

	R=NULL;  //使2个指针什么也不指向
	p=NULL;

	return H; //返回头结点指针，即整个链表

}


//（7.5）单指针实验
//因为要在创建子函数中动态申请内存，
//造成实参的节点指针和形参的指针数值不同,
//实参和形参指针将指向heap中的不同位置，
//子函数返回时，不能向主调函数传递创建的链表。
//且，此种情况会造成内存泄漏（memory leak）
void createTestR(node* L)  //L为node型节点的地址
{
	int i;
	elementType x;
	int n;
	node *p, *R;  //p和R为node型节点的地址，其中R为尾指针，指向表的最后一个节点
	L=new node;  //L为node型节点的指针
	L->next=NULL; //头结点指针域为空。
    
    R=L;  //对空表，头、尾指针相同

	cout<<"请输入元素节点个数（整数）："<<endl;  //控制元素节点的个数
	cin>>n;

	cout<<"请输入元素数据（整数）:"<<endl;
	for(i=n;i>0;i--)  //尾插法
	{
		p=new node;  
		cin>>x;

		p->data=x;
		
		R->next=p;
		R=p;  //尾指针后移
	}
	R->next=NULL; //最后一个节点的next指针为空。

	//打印函数内部创建的链表，但此链表不能返回到主调函数中
	cout<<"这是子函数内打印创建的链表："<<endl;
	p=L->next;
	while(p)
	{
		cout<<p->data<<",";
		p=p->next;
	}

	cout<<endl;
	cout<<"L="<<L<<endl;
}
//（7.5）尾插法创建链表--malloc()申请内存，free()释放内存
void createListRMF( node *& L )
{
	int i;
	int n; //元素节点个数，不含头结点
	elementType x; //数据元素的数值
	node *p, *R; //R为尾节点的指针

	L=(node*)malloc(sizeof(node));  //产生头节点，动态的在heap上申请内存，存放一个节点（头结点）
	L->next=NULL;  //头结点的指针域为空

	R=L;  //设置尾指针，对空表头、尾指针相同

	cout<<"请输入元素节点个数（整数）："<<endl;  //控制元素节点的个数
	cin>>n;

	cout<<"请输入元素数据（整数）:"<<endl;
	for(i=n;i>0;i--)  //尾插法循环插入节点
	{
		p=new node;  //动态申请内存，产生新节点
		cin>>x;

		p->data=x;  //写入元素数据
		
		R->next=p;  //原来尾节点的next指向新节点p
		R=p;        //修改尾指针，使得指向最新产生的节点，即后移一个节点
	}
	R->next=NULL;  //尾节点的next指针为空。

}


//(7.6) 以“9999”作为结束元素输入条件，用引用参数返回链表
void createListR6( node *& L )
{
	elementType x; //数据元素的数值
	node *p, *R; //H为头节点指针，R为尾节点的指针

	L=new node;  //产生头节点，动态的在heap上申请内存，存放一个节点（头结点）
	L->next=NULL;  //头结点的指针域为空

	R=L;  //设置尾指针，对空表:头、尾指针相同



	cout<<"请输入元素数据（整数，-9999退出）:"<<endl;
	cout<<"x=";
	cin>>x;
	
	while(x!=-9999)
	{   
		p=new node;  //动态申请内存，产生新节点

		p->data=x;  //写入元素数据
		
		R->next=p;  //原来尾节点的next指向新节点p
		R=p;        //修改尾指针，使得指向最新产生的节点，即后移一个节点
		
		cout<<"x=";
		cin>>x;
	}
	R->next=NULL;  //尾节点的next指针为空。

	R=NULL;  //使2个指针什么也不指向
	p=NULL;
}

/*---------------------------------------------------------------*/
//8. 头插法构造带有节点的单链表
//用户从键盘输入节点个数
//用户从键盘输入节点元素数据
//新插入的节点位于头节点之后
//分别使用指针的指针和C++的引用方式传回创建的链表

//（8.1）使用C++“引用”实现--头插法创建一个带头结点的链表
void createListH(node* &L)
{
	int i;
	node *p;
	int n;  //存放节点个数
	elementType x;
	L=new node;  //产生头节点，动态的在heap上申请内存，存放一个节点（头结点）
	L->next=NULL;  //头结点的指针域为空

	cout<<"请输入元素节点个数（整数）："<<endl;  //控制元素节点的个数
	cin>>n;

	cout<<"请输入元素数据（整数）:"<<endl;
	for(i=n;i>0;i--)  //头插法
	{
		p=new node;  //动态申请内存
		cin>>x;

		p->data=x;  //写入元素数据
		
		p->next=L->next;  //同插入节点算法
		L->next=p;
	}
}


//（8.2）使用双指针实现--C和C++皆可用
void createListH1(node** A)  //A为node型节点的地址的地址
{
	int i;
	elementType x;
	int n;  //元素节点的个数
	node *p;  //p为node型节点的地址
	(*A)=new node;  //(*A)为node型节点的指针
	(*A)->next=NULL; //头结点指针域为空。
	
	cout<<"请输入元素节点个数（整数）："<<endl;  //控制元素节点的个数
	cin>>n;
	
	cout<<"请输入元素数据（整数）:"<<endl;
	for(i=n;i>0;i--)  //头插法
	{
		p=new node;  
		cin>>x;

		p->data=x;
		p->next=(*A)->next;
		(*A)->next=p;
	}

}

//(8.3) 函数返回值返回链表--返回值类型：节点指针
node* createListH2()
{
	int i;
	node *H, *p;
	int n;  //存放节点个数
	elementType x;
	H=new node;  //产生头节点，动态的在heap上申请内存，存放一个节点（头结点）
	H->next=NULL;  //头结点的指针域为空

	cout<<"请输入元素节点个数（整数）："<<endl;  //控制元素节点的个数
	cin>>n;

	cout<<"请输入元素数据（整数）:"<<endl;
	for(i=n;i>0;i--)  //头插法
	{
		p=new node;  //动态申请内存
		cin>>x;

		p->data=x;  //写入元素数据
		
		p->next=H->next;  //同插入节点算法
		H->next=p;
	}

	p=NULL;

	return H; //返回头结点指针，即整个链表
}
//（8.4）使用C++“引用”实现--头插法创建一个带头结点的链表，特殊符号结束
void createListH4(node* &L)
{
	node *p;
	elementType x;
	L=new node;  //产生头节点，动态的在heap上申请内存，存放一个节点（头结点）
	L->next=NULL;  //头结点的指针域为空

	cout<<"请输入结点数据（整数，-9999退出）："<<endl;  
	cout<<"x=";
	cin>>x;

	while(x!=-9999)
	{
		p=new node;       //动态申请内存
		p->data=x;        //写入元素数据		
		p->next=L->next;  //头插
		L->next=p;

		cout<<"x=";
		cin>>x;
	}
}
//随机数头插法创建链表开始------------------------------------------------------------------
//8.5随机数头插法创建
void rndCList(node *&L)
{
	int i;
	int n,m;
	node *p;

	L=new node;  //产生头节点，动态的在heap上申请内存，存放一个节点（头结点）
	L->next=NULL;  //头结点的指针域为空

	cout<<"请输入要产生的随机数个数，n=";
	cin>>n;
	
	cout<<"请输入控制随机数大小参数，比如100以内数，请输入100，m=";
	cin>>m;    
	
	srand((unsigned)time(NULL));	//产生随机数种子
	//srand((unsigned)GetTickCount());	//产生随机数种子
	for(i=0;i<n;i++)
	{
		p=new node;
		p->data=rand()%m;     //随机数写入结点

		p->next=L->next;      //头插接入新结点
		L->next=p;
    }
	cout<<endl;
}
//随机数头插法创建链表结束------------------------------------------------------------------

//（8.5）单指针实验
//因为要在创建子函数中动态申请内存，
//造成实参的节点指针和形参的指针数值不同,
//实参和形参指针将指向heap中的不同位置，
//子函数返回时，不能向主调函数传递创建的链表。
//且，此种情况会造成内存泄漏（memory leak）
void createTest(node* L)  //L为node型节点的地址
{
	int i;
	elementType x;
	int n;
	node *p;  //p为node型节点的地址
	L=new node;  //L为node型节点的指针
	L->next=NULL; //头结点指针域为空。

	cout<<"请输入元素节点个数（整数）："<<endl;  //控制元素节点的个数
	cin>>n;

	cout<<"请输入元素数据（整数）:"<<endl;
	for(i=n;i>0;i--)  //头插法
	{
		p=new node;  
		cin>>x;

		p->data=x;
		p->next=L->next;
		L->next=p;
	}

	//打印函数内部创建的链表，但此链表不能返回到主调函数中
	cout<<"这是子函数内打印创建的链表："<<endl;
	p=L->next;
	while(p)
	{
		cout<<p->data<<",";
		p=p->next;
	}

	cout<<endl;
	cout<<"L="<<L<<endl;
}


/*---------------------------------------------------------------*/
//***********************************************************//
//* 9. 销毁链表                                             *//
//*    释放链表占据的“堆”空间                             *//
//*    用户在“堆”上，用new操作符，或malloc()函数          *//
//* 动态申请的内存空间，必须手工释放，否则造成内存泄漏。    *//
//* malloc()和free()是一对函数，分别用于申请和释放          *//
//* new和delete是一对操作符，分别用于申请和释放，只能C++中用*//
//* 申请和释放必须成对使用，否则造成内存泄漏                *//
//***********************************************************//


//9.1 对用 new 申请的内存，delete 释放内存
//************************************************************//
//* 函数功能：释放链表空间                                   *//
//*           C++的delete操作符释放                          *//
//* 输入参数：node* & L                                      *//
//* 输出参数：node* & L                                      *//
//* 返 回 值：空                                             *//
//* 文 件 名：linkedList.h  函 数 名：destroyList            *//
//************************************************************//
void destroyList(node* & L)
{
	node *p,*pTemp;
	p=L;
	while(p)
	{
		pTemp=p->next;
		delete(p);
		p=pTemp;
	}
	L=NULL;
}
//9.2 对用 malloc() 申请的内存，用free() 释放内存
//************************************************************//
//* 函数功能：释放链表空间                                   *//
//*           free()函数释放，C和C++中可用                   *//
//* 输入参数：node* & L                                      *//
//* 输出参数：node* & L                                      *//
//* 返 回 值：空                                             *//
//* 文 件 名：linkedList.h  函 数 名：destroyListMF          *//
//************************************************************//
void destroyListMF(node* & L)
{
	node *p,*pTemp;
	p=L;
	while(p)
	{
		pTemp=p->next;
		free(p);
		p=pTemp;
	}
	L=NULL;
}

//问题：
//1.为什么在顺序表中没有释放内存的问题？
//2.用new申请，用free()释放；或用malloc()申请，用delete释放是否可行？
//3.为什么函数参数用了指针的引用？用单指针行不行？双指针可以吗？
/*---------------------------------------------------------------*/


//打印链表元素
void printList(node* L)
{
	node* p;
	

	cout<<"当前表长度为："<<listLength(L)<<endl;
	cout<<"当前表中元素："<<endl;	
	p=L->next;  //p指向第一个元素结点
	while(p)
	{
		cout<<p->data<<"\t";
		p=p->next;
	}
	cout<<endl;
}